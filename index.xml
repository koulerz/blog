<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kouler</title>
    <link>https://kouler.com/</link>
    <description>Recent content on Kouler</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 24 Dec 2020 13:15:58 +0800</lastBuildDate>
    
	<atom:link href="https://kouler.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>macOS BigSur 开启显示器 HiDPI 方法</title>
      <link>https://kouler.com/posts/macos-bigsur-%E5%BC%80%E5%90%AF%E6%98%BE%E7%A4%BA%E5%99%A8hidpi%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 24 Dec 2020 13:15:58 +0800</pubDate>
      
      <guid>https://kouler.com/posts/macos-bigsur-%E5%BC%80%E5%90%AF%E6%98%BE%E7%A4%BA%E5%99%A8hidpi%E6%96%B9%E6%B3%95/</guid>
      <description>过去为显示器设置 HiDPI 的方法仍然有效，可以查看参考和扩展中给出的链接。只是在最后遇到一个文件系统权限问题。
解决无法将文件写入只读文件系统问题 macOS BigSur 系统中加入了只读文件系统，无法再使用过去的方式将配置文件写入直接拷贝到 /System/Library/Displays/Contents/Resources/Overrides 目录中。即便开启了 SIP 也不行。
解决方法是将需要的文件写入 /Library/Displays/Contents/Resources/Overrides 目录中。写入该目录中同样有效。
使用脚本自动修改 发现一个自动适配 HiDPI 的脚本，但目前未测试使用。
https://github.com/mlch911/one-key-hidpi
参考 &amp;amp; 扩展  macOS 下开启显示器 HiDPI 方法 macOS 无法获得权限问题 One key HiDPI  </description>
    </item>
    
    <item>
      <title>常用的进程操作命令</title>
      <link>https://kouler.com/posts/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Wed, 29 Jul 2020 20:21:02 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</guid>
      <description>查看和检索进程   使用 ps 命令列出所有进程信息
1ps aux   使用 ps 命令检索进程
1ps aux|grep keyword   使用 pgrep 命令检索进程，该命令将打印出所有检索到的进程 ID
1pgrep keyword   使用 lsof 命令根据端口号检索进程
1lsof -i:22   使用 ps 命令检索进程
1# sed &amp;#39;1d&amp;#39; 删除第一行的内容，当输出结果中第一行为标题或其他非有效内容时可以删除 2# awk &amp;#39;{print $2}&amp;#39; 打印每一行中的 PID 列 3ps -ef| grep &amp;#34;go&amp;#34; | sed &amp;#39;1d&amp;#39; | awk &amp;#39;{print $2}&amp;#39;   中断进程   使用 kill 命令中断进程。kill 命令向指定进程发送信号，默认信号为 15（TERM 信号），表示终止进程
1# 向 PID 为 123 的进程发送信号 15 2kill 123 3 4# 向 PID 为 123 的进程发送信号 9，强制终止进程 5kill -9 123 常用信号：</description>
    </item>
    
    <item>
      <title>Docker 常用命令</title>
      <link>https://kouler.com/posts/docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 27 Jul 2020 00:22:31 +0800</pubDate>
      
      <guid>https://kouler.com/posts/docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>查看 Docker 信息   常看 docker 版本：
1$ docker version   查看 docker 系统信息：
1$ docker info   镜像操作  从 DockerHub 检索镜像 1$ docker search &amp;lt;image_name&amp;gt;  拉取镜像 1$ docker pull &amp;lt;image_name&amp;gt;  删除镜像 1$ docker rmi &amp;lt;image_name&amp;gt;  列出镜像 1$ docker images  显示镜像历史 1$ docker history &amp;lt;image_name&amp;gt;  上传镜像到 Docker Hub 1# 为镜像添加附带作者信息的标签 2$ docker tag &amp;lt;image_name&amp;gt;:&amp;lt;label&amp;gt; &amp;lt;author_name&amp;gt;/&amp;lt;image_name&amp;gt;:&amp;lt;label&amp;gt; 3 4# 上传附带作者信息标签的镜像到 Docker Hub 5$ docker push &amp;lt;author_name&amp;gt;/&amp;lt;image_name&amp;gt;:&amp;lt;label&amp;gt;   容器启动   启动容器并启动 bash：</description>
    </item>
    
    <item>
      <title>使用 Fiddler 捕获手机流量</title>
      <link>https://kouler.com/posts/%E4%BD%BF%E7%94%A8fiddler%E6%8D%95%E8%8E%B7%E6%89%8B%E6%9C%BA%E6%B5%81%E9%87%8F/</link>
      <pubDate>Thu, 12 Mar 2020 00:41:43 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E4%BD%BF%E7%94%A8fiddler%E6%8D%95%E8%8E%B7%E6%89%8B%E6%9C%BA%E6%B5%81%E9%87%8F/</guid>
      <description>Fiddler 设置  打开 Fiddler 连接设置，Tools-&amp;gt;Fiddler Options-&amp;gt;Connections 设置允许远程计算机连接，Allow remote computers to connect 可以自定义端口，默认端口为 8888，Fiddler listens on port 确认设置，OK 重启 Fiddler  手机端设置  确保手机和电脑在同一局域网内 在当前无线网络高级设置中手动配置 HTTP 代理  IP 地址为电脑 IP 地址。鼠标移至 Fiddler 主界面右上 Online 字样处可查看当前 IP 地址 端口为 Fiddler 监听端口。默认为 8888   禁用移动数据并关闭 VPN，使得数据通过无线网络代理传输 打开手机浏览器，访问代理地址。例如: http://192.168.1.111:8888。正常情况下会打开 Fiddler Echo Service 页面 点击页面中的 FiddlerRoot certificate 链接下载证书 安装证书  </description>
    </item>
    
    <item>
      <title>通过启动参数设置 Chrome 禁止加载图片</title>
      <link>https://kouler.com/posts/%E9%80%9A%E8%BF%87%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AEchrome%E7%A6%81%E6%AD%A2%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87/</link>
      <pubDate>Sun, 08 Mar 2020 05:56:37 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E9%80%9A%E8%BF%87%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AEchrome%E7%A6%81%E6%AD%A2%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87/</guid>
      <description>试用 chromedp 时，希望启动的浏览器能够实现禁止加载图片的功能，以节省资源消耗。
在 chromedp Github 仓库 Issues 中找到了相关提问和答案。启动浏览器时通过设置启动参数 blink-settings 的值为 imagesEnabled=false 得以实现。
参考 &amp;amp; 扩展  chromedp how to disable images load Chrome 命令行可配置参数 Chrome 命令行参数 blink-settings 的所有配置项  </description>
    </item>
    
    <item>
      <title>使用 Hugo</title>
      <link>https://kouler.com/posts/use-hugo/</link>
      <pubDate>Fri, 17 Jan 2020 22:42:14 +0800</pubDate>
      
      <guid>https://kouler.com/posts/use-hugo/</guid>
      <description>Hugo 安装和配置  Hugo Documentation minimal-bootstrap-hugo-theme  Hugo 常用命令 1$ hugo help // 帮助命令 2$ hugo version // 打印版本号 3$ hugo new site sitename // 创建新站点 4$ hugo new posts/new-post.md // 创建新文章 5$ hugo // 生成静态页面 6$ hugo server // 启动 Hugo Web Server 在 Github 托管 Hugo  Host on GitHub  Github Pages site 配置个人域名  在发布项目根目录添加 CNAME 文件，内容为个人域名 配置个人域名 DNS，添加 CNAME 记录，将 www 子域指向个人 Github Pages site 地址，yourname.</description>
    </item>
    
    <item>
      <title>ZSH 环境变量失效问题</title>
      <link>https://kouler.com/posts/zsh%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 06 Nov 2019 13:52:42 +0800</pubDate>
      
      <guid>https://kouler.com/posts/zsh%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</guid>
      <description>环境变量失效 默认 shell 修改为 zsh 后，.bash_profile 中的环境变量全部失效
解决方法  用户目录下创建 .zshrc 文件 将以下命令写入文件 source ~/.bash_profile  重启终端后可解决
终端用户名配置未生效 .bash_profile 中的终端用户名配置（PS1）仍未生效 export PS1=&#39;\[\033[01;36m\]\w \[\033[00m\]\$ &#39;
解决方法 解决 zsh 环境变量失效的问题后，在 .bash_profile 文件中修改 PS1 的值
## 修改前 export PS1=&#39;\[\033[01;36m\]\w \[\033[00m\]\$ &#39; # for bash ## 修改后 export PS1=&#39;%~ %(!.#.$) &#39; # for zsh 参考  环境变量怎么配置都不起作用？已经解决！一切源于 zsh zsh prompt expansion  </description>
    </item>
    
    <item>
      <title>macOS 桌面壁纸路径</title>
      <link>https://kouler.com/posts/macos%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Tue, 08 Oct 2019 22:33:42 +0800</pubDate>
      
      <guid>https://kouler.com/posts/macos%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8%E8%B7%AF%E5%BE%84/</guid>
      <description>默认路径  /Library/Desktop Pictures /System/Library/Desktop Pictures  查看当前桌面壁纸路径 输入以下命令后会在桌面显示当前桌面壁纸所在路径
1$ defaults write com.apple.dock desktop-picture-show-debug-text -bool TRUE 2$ killall Dock 输入以下命令后不再显示当前壁纸路径
1$ defaults delete com.apple.dock desktop-picture-show-debug-text 2$ killall Dock 参考  找不到当前壁纸文件的路径  </description>
    </item>
    
    <item>
      <title>关闭 macOS Catalina Read-only Volume</title>
      <link>https://kouler.com/posts/%E5%85%B3%E9%97%AD-macos-catalina-read-only-volume/</link>
      <pubDate>Tue, 08 Oct 2019 20:20:42 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E5%85%B3%E9%97%AD-macos-catalina-read-only-volume/</guid>
      <description>运行以下命令即可关闭 Read-only Volume，系统重启后命令会失效
1$ sudo mount -uw / 2 3# killall Finder 参考  macOS Catalina Read-only file system with SIP disabled  </description>
    </item>
    
    <item>
      <title>Tmux 常用命令和快捷键</title>
      <link>https://kouler.com/posts/tmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/</link>
      <pubDate>Wed, 07 Aug 2019 17:43:42 +0800</pubDate>
      
      <guid>https://kouler.com/posts/tmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid>
      <description>Tmux 命令 # 开启一个 Tmux Session $ tmux new -s name # 使会话在后台运行，等同于 `Ctrl + B` + `D` $ tmux detach # 查看当前 Tmux 中有哪些 Session $ tmux ls # 回到 Tmux Session 中 $ tmux a -t name（or at，or attach） # 关闭demo会话 tmux kill-session -t demo # 关闭服务器，所有的会话都将关闭 tmux kill-server Tmux 快捷键 Tmux Session 中的命令需要先按下 Tmux 前缀键（默认是 Ctrl + B）
# 会话（Session） 指令 ? # 快捷键帮助列表 d # detach，退出 Tmux Session，回到父级 Shell r # 强制重载当前会话 : # 进入命令行模式，此时可直接输入ls等命令 s # 列出所有 Session，可通过 j, k, 方向键选择，回车切换 $ # 为当前 Session 命名 # 窗口（window）指令 c # 新建 Window &amp;amp; # 关闭当前窗口 p # 切换到上一窗口 n # 切换到下一窗口 0~9 # 切换到指定窗口 &#39; # 切换到指定索引的窗口，比如索引号大于 9 的窗口 w # 打开窗口列表，用于且切换窗口 , # 为当前窗口命名 .</description>
    </item>
    
    <item>
      <title>CentOS7 架设 FTP 服务</title>
      <link>https://kouler.com/posts/centos7%E6%9E%B6%E8%AE%BEftp%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Sun, 04 Aug 2019 18:59:42 +0800</pubDate>
      
      <guid>https://kouler.com/posts/centos7%E6%9E%B6%E8%AE%BEftp%E6%9C%8D%E5%8A%A1/</guid>
      <description>大概操作流程 之前已经安装了 vsftpd 服务，并修改了配置
目前的状况是浏览器端可以登录，但无法显示文件列表
 开机并启动 vsfptd # 启动服务 service vsftpd start # 停止服务 service vsftpd stop # 重启服务 service vsftpd restart # 查看状态 service vsftpd status  Docker 中安装了 ftp 命令行工具，登录时提示错误 vsftpd: refusing to run with writable root inside chroot() 更改挂载目录的拥有者，仍然提示错误 挂载硬盘出错 mount /dev/sdb is write-protected mounting read-only mount: unknown filesystem type &#39;(null)&#39; 硬盘格式为 ntfs，格式化为linux支持的格式可以解决该问题，但硬盘中有数据，放弃了该方法 安装 ntfs-3g，使用该工具挂载硬盘 命令行登录ftp，提示错误 500 Illegal PORT command 将 vsftpd 设置为被动模式，增加 vsftpd 配置项 # 开启被动模式 pasv_enable=YES # 被动模式最低端口 pasv_min_port=30000 # 被动模式最高端口 pasv_max_port=31000  仍然看不到文件列表 下载 ftp 客户端，使用 filezilla 登录 ftp 发现将 ntfs 挂载之后目录权限均为 root，使用 chown 更改所属用户没有效果，后来通过 ntfs-3g 挂载时设置用户和用户组为 vsftpd 用户 SELinux 在访问 ftp 时收到警告 设置 SELinux 对 ftp 的控制，允许访问目录 # 查看 SELinux 中 ftp 权限 getsebool -a | grep ftp # 允许 ftp 访问目录 setsebool -P tftp_home_dir 1 setsebool -P allow_ftpd_full_access 1  解决错误 vsftpd: refusing to run with writable root inside chroot()，在 vsftpd 配置文件中添加 allow_writeable_chroot=YES ftp 仍然无法显示挂载硬盘的目录列表，原因是设置 ftp 为被动模式，防火墙阻止了之前设置的用于传输数据的被动模式端口 30000-31000 批量开放防火墙端口 firewall-cmd --permanent --zone=public --add-port=30000-31000/tcp firewall-cmd --reload  设置开机启动 vsftpd 服务 chkconfig vsftpd on 设置开机自动挂载 NTFS 硬盘 # 编辑 /etc/fstab 文件 UUID=831df52d-baad-4902-bcce-6128cec95411 /home/vsftpd/ftp ntfs-3g defaults 0 0   参考  vsftpd：500 OOPS: vsftpd: refusing to run with  如何更改linux文件的拥有者及用户组(chown和chgrp) vsftpd 服务器报错：500 OOPS: vsftpd: refusing to run with writable root inside chroot() vsftpd配置文件详解 Centos/Linux 挂载移动ntfs硬盘 Centos 7 挂载 NTFS 分区 500 Illegal PORT command的问题（FTP主被动模式） CentOS下vsftp设置、匿名用户&amp;amp;本地用户设置、PORT、PASV模式设置 CentOS 6和CentOS 7防火墙的关闭 linux中ftp查看不到文件列表的问题 如何更改linux文件的拥有者及用户组(chown和chgrp) Linux查看用户所属的组 Linux 系统的 NTFS-3G 权限 查看 SELinux状态及关闭SELinux CentOS7 搭建vsftpd详细教程 vsftpd设置后无法登陆，解决OOPS: vsftpd: refusing to run with writable root inside chroot() vsftpd不能显示文件目录的解决方法 Centos防火墙设置与端口开放的方法 CentOS 7 开放防火墙端口命令 CentOS7下firewall批量开放端口 CentOs 设置开机启动vsftpd服务 CentOS设置设备开机自动挂载 centos7.</description>
    </item>
    
    <item>
      <title>CentOS7 笔记本关闭合盖睡眠</title>
      <link>https://kouler.com/posts/centos7%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%85%B3%E9%97%AD%E5%90%88%E7%9B%96%E7%9D%A1%E7%9C%A0/</link>
      <pubDate>Thu, 11 Jul 2019 12:14:42 +0800</pubDate>
      
      <guid>https://kouler.com/posts/centos7%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%85%B3%E9%97%AD%E5%90%88%E7%9B%96%E7%9D%A1%E7%9C%A0/</guid>
      <description>具体流程  修改配置文件/etc/systemd/logind.conf，去掉HandleLidSwitch行的注释，并将其值由suspend改为ignore 执行systemctl restart systemd-logind命令，使刚才的修改生效  修改后的文件内容如下：
[Login] #NAutoVTs=6 #ReserveVT=6 #KillUserProcesses=no #KillOnlyUsers= #KillExcludeUsers=root #InhibitDelayMaxSec=5 #HandlePowerKey=poweroff #HandleSuspendKey=suspend #HandleHibernateKey=hibernate HandleLidSwitch=ignore #HandleLidSwitchDocked=ignore #PowerKeyIgnoreInhibited=no #SuspendKeyIgnoreInhibited=no #HibernateKeyIgnoreInhibited=no #LidSwitchIgnoreInhibited=yes #IdleAction=ignore #IdleActionSec=30min #RuntimeDirectorySize=10% #RemoveIPC=no #UserTasksMax= 如需再次进入待机状态，可执行systemctl suspend命令。
通过修改配置文件自定义电源管理 # /etc/systemd 动作: HandlePowerKey # 按下电源键后的动作 HandleSleepKey # 按下挂起键后的动作 HandleHibernateKey # 按下休眠键后的动作 HandleLidSwitch # 合上笔记本盖后待机 动作允许的值: ignore # 不执行任何操作 poweroff # 关机 reboot # 重新启动 halt # 关机 suspend # 待机挂起 hibernate # 休眠 参考  CentOS 7.0 笔记本关闭合盖睡眠  </description>
    </item>
    
    <item>
      <title>Screen 命令配置和常用操作</title>
      <link>https://kouler.com/posts/screen%E5%91%BD%E4%BB%A4%E9%85%8D%E7%BD%AE%E5%92%8C%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 10 Jul 2019 20:48:42 +0800</pubDate>
      
      <guid>https://kouler.com/posts/screen%E5%91%BD%E4%BB%A4%E9%85%8D%E7%BD%AE%E5%92%8C%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</guid>
      <description>配置文件 该配置在screen底部状态栏显示窗口列表的名称，更易于管理会话和窗口
## ~/.screenrc ## 屏幕缓冲区4096行 defscrollback 4096 ## 下标签设置 hardstatus on hardstatus alwayslastline hardstatus string &amp;quot;%{= kw}%-w%{= kG}%{+b}[%n %t]%{-b}%{= kw}%+w %=%d %M %0c %{g}%H%{-}&amp;quot; termcapinfo rxvt &#39;hs:ts=\E]2;:fs=\007:ds=\E]2;screen\007&#39; termcapinfo xterm ti@:te@ termcapinfo xterm &#39;hs:ts=\E]2;:fs=\007:ds=\E]2;screen\007&#39; 常用操作 1screen -S name # 创建名称为 name 的会话 2screen -t name # 创建名称为 name 的窗口 3screen -ls # 显示存在的会话 4screen -r name # 唤起一个被放入后台的会话 Ctrl + a, ? # 显示所有按键绑定信息 Ctrl + a, w # 显示所有窗口列表 Ctrl + a, Ctrl + a # 切换到之前的窗口 Ctrl + a, d # 暂离当前会话，将当前会话放入后台 Ctrl + a, c # 在当前会话中创建一个新窗口 Ctrl + a, A # 为当前窗口设置名称 Ctrl + a, p # 上一个窗口 Ctrl + a, n # 下一个窗口 Ctrl + a, 0-9 # 切换到 0-9 窗口 Ctrl + a, k # 杀掉当前窗口 Ctrl + a, [ # 拷贝模式 </description>
    </item>
    
    <item>
      <title>解决 Composer 无法下载代码库问题</title>
      <link>https://kouler.com/posts/%E8%A7%A3%E5%86%B3composer%E6%97%A0%E6%B3%95%E4%B8%8B%E8%BD%BD%E4%BB%A3%E7%A0%81%E5%BA%93%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 13 May 2019 19:20:42 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E8%A7%A3%E5%86%B3composer%E6%97%A0%E6%B3%95%E4%B8%8B%E8%BD%BD%E4%BB%A3%E7%A0%81%E5%BA%93%E9%97%AE%E9%A2%98/</guid>
      <description>可以尝试为 composer 设置国内镜像，代码如下
1$ composer config repo.packagist composer https://mirrors.aliyun.com/composer/ 参考&amp;amp;扩展  Composer 中文镜像  </description>
    </item>
    
    <item>
      <title>解决 VSCode 无法安装 Golang 扩展问题</title>
      <link>https://kouler.com/posts/%E8%A7%A3%E5%86%B3vscode%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85golang%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 13 May 2019 19:18:42 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E8%A7%A3%E5%86%B3vscode%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85golang%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98/</guid>
      <description>SS 方法 1 从 SS 复制 HTTP Proxy Shell Export Line
2 设置 Shell 代理
1export http_proxy=http://127.0.0.1:1087; 2export https_proxy=http://127.0.0.1:1087; 3 使用 go get 方式安装
Goproxy 环境变量方法 go 1.11 版本开始新增了 goproxy 环境变量，用于下载源码时设置代理地址
1export GOPROXY=https://goproxy.io 该方法依赖 go module 功能
Go module replace 方法 在 go.mod 文件中将无法安装的包路径替换为其他能够访问的包路径，比如 github 下的包路径
1module hello 2 3require ( 4 golang.org/x/text v0.3.0 5) 6 7# 将限制访问的 golang.org 下的地址替换为能够访问的 github 地址 8replace ( 9 golang.org/x/text =&amp;gt; github.com/golang/text v0.3.0 10) 由于包依赖通常比较多和杂，所以不推荐使用该方法</description>
    </item>
    
    <item>
      <title>Mac 在登录屏隐藏账户</title>
      <link>https://kouler.com/posts/mac%E5%9C%A8%E7%99%BB%E5%BD%95%E5%B1%8F%E9%9A%90%E8%97%8F%E8%B4%A6%E6%88%B7/</link>
      <pubDate>Wed, 07 Nov 2018 09:27:42 +0800</pubDate>
      
      <guid>https://kouler.com/posts/mac%E5%9C%A8%E7%99%BB%E5%BD%95%E5%B1%8F%E9%9A%90%E8%97%8F%E8%B4%A6%E6%88%B7/</guid>
      <description>1# 在登录屏隐藏 PostgreSQL 账户 2$ sudo dscl . create /Users/postgres IsHidden 1 3 4# 在登录屏隐藏 hiddenuser 账户 5$ sudo dscl . create /Users/hiddenuser IsHidden 1 6 7# 在登录屏隐藏通过 other... 登录 8$ sudo defaults write /Library/Preferences/com.apple.loginwindow SHOWOTHERUSERS_MANAGED -bool FALSE 9 参考 &amp;amp; 扩展  Hide PostgreSQL user in OSX Yosemite Hide a user account in macOS Remove “Other…” from Login screen  </description>
    </item>
    
    <item>
      <title>PHP 代码临时修改配置</title>
      <link>https://kouler.com/posts/php%E4%BB%A3%E7%A0%81%E4%B8%B4%E6%97%B6%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Tue, 06 Nov 2018 19:01:42 +0800</pubDate>
      
      <guid>https://kouler.com/posts/php%E4%BB%A3%E7%A0%81%E4%B8%B4%E6%97%B6%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE/</guid>
      <description>1&amp;lt;?php 2 3// 修改程序最大执行时间 为 300s 4ini_set(&amp;#34;max_execution_time&amp;#34;, 300); 5 6// 修改程序内存限制为 128M 7ini_set(&amp;#34;memory_limit&amp;#34;, &amp;#34;128M&amp;#34;); </description>
    </item>
    
    <item>
      <title>Lumen 加载根目录配置文件</title>
      <link>https://kouler.com/posts/lumen%E5%8A%A0%E8%BD%BD%E6%A0%B9%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 11 Oct 2018 22:57:42 +0800</pubDate>
      
      <guid>https://kouler.com/posts/lumen%E5%8A%A0%E8%BD%BD%E6%A0%B9%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid>
      <description>Lumen 版本: 5.3
 在根目录创建 config 目录 在 config 目录中新建配置文件 在 bootstrap/app.php 中加载配置文件  1&amp;lt;?php 2 3// bootstrap/app.php 4$app-&amp;gt;configure(&amp;#39;fileName&amp;#39;); 5 6// Example: $app-&amp;gt;configure(&amp;#39;mail&amp;#39;); 参考&amp;amp;扩展  Lumen 加载根目录配置文件  </description>
    </item>
    
    <item>
      <title>面向接口编程</title>
      <link>https://kouler.com/posts/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Wed, 26 Sep 2018 12:47:42 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/</guid>
      <description>面向接口编程和面向对象编程的关系 面向接口编程和面向对象编程并不是平级的，面向接口编程并不是比面向对象编程更先进的一种独立的编程思想，而是附属于面向对象思想体系，属于其中的一部分。或者说，它是面向对象编程体系中的思想精髓之一。
面向接口编程综述 面向接口编程是在系统分析和架构设计中，分清层次和依赖关系，每个层级不直接向其上层提供服务（即不是直接实例化在上层中），而是通过定义一组接口，仅向上层暴露其接口功能，上层对于下层仅仅是接口依赖，而不依赖具体类。
这样做的好处是显而易见的，首先对系统灵活性大有好处。当下层需要改变时，只要接口及接口功能不变，则上层不用做任何修改。甚至可以在不改动上层代码时将下层整个替换掉。比如我们将一个 WD 的 60G 硬盘换成一个希捷的 160G 的硬盘，计算机其他地方不用做任何改动，只需要将原硬盘拔下来，新硬盘插上就行了，因为计算机其他部分不依赖具体硬盘，而只依赖一个 IDE 接口，只要硬盘实现了这个接口，就可以替换上去。从这里看，程序中的接口和现实中的接口极为相似。
使用接口的另一个好处就是不同部件或层次的开发人员可以并行开工，就像造硬盘的不用等造 CPU 的，也不用等造显示器的，只要接口一致，设计合理，完全可以并行进行开发，从而提高效率。
关于抽象类和接口 如果从具体代码来看，对这两个概念很容易模糊。而单从具体功能来看，甚至觉得接口就是多余的，因为除多重继承外，抽象类似乎能完全取代接口。
但接口的存在当然不只是为了实现多重继承。抽象类和接口的区别在于使用动机。使用抽象类是为了代码的复用，而使用接口的动机是为了实现多态性。
Person 这个接口该不该定义，关键看具体应用中的使用情况。如果程序中有 Women 和 Man，都继承 Person，而且 Women 和 Man 绝大多数方法都相同，只有一个方法 ToWC() 不同，那么定义一个 AbstractPerson 抽象类比较合理，因为它可以把其他所有方法都包含进去，子类只定义 ToWC()，大大减少了重复代码量。
但是，如果程序中的 Women 和 Man 两个类基本没有共同代码，而且有一个 PersonHandle 类需要实例化他们，并且不希望知道他们是男是女，而只需把他们当作人看待，并实现多态，那么定义成接口就有必要了。
总而言之，接口与抽象类的区别主要在于使用的动机，而不在于其本身。而一个东西该定义成抽象类还是接口，要根据具体环境的上下文决定。
面向接口编程的代码优化示例 我们要实现老师教儿童背古诗的功能，代码如下：
1// 老师 2class Teacher { 3 public void teach(Children children){} // 教儿童背古诗 4} 5 6// 儿童 7class Children { 8 public void listen(){} // 听课 9 public void recite(){} // 背诵 10} 11 12/* 这是标准的面向对象编程，描述了对象间的关联 */ 随着老师能力的提升，准备扩展服务对象，增加在校学生，代码如下：</description>
    </item>
    
    <item>
      <title>软件架构设计</title>
      <link>https://kouler.com/posts/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Wed, 26 Sep 2018 11:00:42 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</guid>
      <description>子系统的设计 在软件设计的过程中，往往需要对系统的结构层次进行分析，从中抽取出系统的设计框架，通过框架来指导整个软件设计的流程。而一个良好的系统框架也是决定整个系统的稳定性、封闭性、可维护性的重要条件之一。
复杂的系统，最好先按业务领域横向拆分成可独立部署的子系统，每个子系统内部再按技术和业务纵向拆分成不同的模块。
举例来说，按照一般的模块化或者功能拆分方法，我们可以将一个完善的电商系统分解为商品、库管、订单、支付、财务、结算、配送、搜索、CRM、虚拟货币、优惠票券、短信、邮件、活动等子系统。而子系统可以再次按照模块或者功能细分，比如订单系统可以按商品品类或者活动类型或者线上线下等维度拆分。支付系统可以按照内外部支付方式、支付和风控策略、支付模式（如跳转或直连等）等不同维度进行划分。
子系统设计准则   分而治之，划分模块 子系统还可以拆分子系统，服务还可以拆分子服务，这里涉及到一个粒度的问题，非常考验设计者的水平和经验，需要准确把握，否则很容易过度设计
  分层
如果真正理解分层的含义，在很多情况下，多层不如经典三层
  保证隔离，划清界限 不要过多假设，不要拖泥带水，任何模块或服务只做它该做的事情。实现隔离的最佳方法，就是面向接口编程，而不是针对具体实现编程 Programming to an Interface, not an Implementation
  多态
如果一定要复用类，请优先使用对象的组合而非继承
  提取变化剧烈的点，定期重构，核心业务逻辑必须单元测试
UI 变化最大，其次是业务逻辑，很多时候 UI 变化会直接影响后端业务逻辑，所以，接口设计要向 UI 和业务逻辑倾斜，基础框架和服务相对稳定，无需过度设计
  模块的设计 系统模块划分过程中，要充分遵照当前系统的框架结构。模块的划分要和系统的结构层次相结合，根据系统层次对各个模块也进行层次划分。如果系统的模块划分和框架结构相违背的话，则会导致数据混乱，接口复杂，模块耦合性过高等问题出现。
进行模块划分时，很多情况下不能清晰的把握每个模块的具体内容。往往会从需求归类或数据统一的角度上来设计模块。这种设计理念是对的，但如果只是单纯从这几个方面进行模块设计，会导致在模块划分上出现一些问题。
比如设计的某一个模块，虽然数据接口统一，但内部实现的功能非常多，单一模块的规模过大，包含的内容过多，会导致程序实现难度增加，数据处理流程变得复杂，程序维护性降低，出错范围不易确定等问题出现。同时，由于模块实现的功能丰富，则必然会导致接口也变得繁多，那么与其他模块之间的独立性就得不到保证，严重影响对程序的理解。
在设计模块的时候，需要遵循每个模块功能单一、接口简单、结构精简的原则。确保每个模块的规模不要太大，接口尽量单一简化。这样可能会导致模块数量比较多，但能够确保模块的独立性，且不会影响系统的整体框架结构。
模块划分的意义：  功能完整独立，数据接口简单 程序易于实现，提高软件开发速度的同时能兼顾软件质量 程序实现逻辑更加清晰，可读性强，易于理解和维护 多人合作开发分工更明确，容易控制 系统运行可方便地选择不同的流程 易于测试和维护 有利于限制错误范围 抽象出可公用的模块，可维护性强，以避免同一处修改在多个地方出现 能充分利用可以重用的代码 基于模块化设计优秀的系统，方便的组装开发新的相似系统，甚至一个全新系统  模块划分准则  高内聚低耦合 规模适中 大模块分解不充分；小模块使用开销大，接口复杂。 功能单一明确 最好做到模块与目标的一一对应。方便单个模块的调试。 接口简单一致 设计应该使得信息传递简单并且与模块的功能一致。 尽量保证单入口单出口 避免内容耦合，易于理解和维护。 功能可预测
相同的输入应该有相同的输出，否则难以理解、测试和维护。 联系尽可能少 对于必须的联系都应该有明确的说明，  模块化的实现 抽象： 抽出事物的本质特性而暂时不考虑它们的细节</description>
    </item>
    
    <item>
      <title>Golang WASM Demo</title>
      <link>https://kouler.com/posts/golang-wasm-demo/</link>
      <pubDate>Sun, 26 Aug 2018 16:14:42 +0800</pubDate>
      
      <guid>https://kouler.com/posts/golang-wasm-demo/</guid>
      <description>Golang 1.11 加入了对 WebAssembly 的支持，以下会测试并运行一个简单的 Demo。
 MacOS 10.13.6 Golang 1.11 Chrome 68 (64-bit)   编写测试代码并编译为 WASM 二进制代码 编写 WebServer 代码用于正确加载本地 WASM 文件 使用 Golang 编写好的 HTML 和 JavaScript 加载 WASM 使用浏览器测试代码  编译测试代码 1// 测试代码 main.go 2package main 3 4import &amp;#34;fmt&amp;#34; 5 6func main() { 7 fmt.Println(&amp;#34;hello, Go/WASM!&amp;#34;) 8} 1# 编译命令 修改编译好的文件名称为 test.wasm 以便被自带的 HTML 文件正确加载 2$ GOOS=js GOARCH=wasm go build -o test.wasm main.go 编写 WebServer 代码 1// server.</description>
    </item>
    
    <item>
      <title>解决 Cron 不能正常执行 Laravel 计划任务</title>
      <link>https://kouler.com/posts/%E8%A7%A3%E5%86%B3cron%E4%B8%8D%E8%83%BD%E6%AD%A3%E5%B8%B8%E8%B0%83%E7%94%A8laravel%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/</link>
      <pubDate>Tue, 14 Aug 2018 11:13:42 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E8%A7%A3%E5%86%B3cron%E4%B8%8D%E8%83%BD%E6%AD%A3%E5%B8%B8%E8%B0%83%E7%94%A8laravel%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/</guid>
      <description>在 Cron 文件中添加了以下 Laravel 任务调度命令后，发现没有正常执行，而直接在终端执行该命令是正常的
1* * * * * php /path/artisan schedule:run &amp;gt;&amp;gt; /dev/null 2&amp;gt;&amp;amp;1 在 Cron 文件中添加以下输出测试命令，也可以正常执行
1* * * * * echo 111 &amp;gt;&amp;gt; /path/test 安装 Rsyslog 后查看 Cron 日志，并没有发现任何异常，日志正常输出每一次的调度命令
然后尝试将 Laravel 任务调度命令执行结果输出到文件，修改 Cron 文件后并没有在输出文件中发现任何内容
1* * * * * php /path/artisan schedule:run &amp;gt;&amp;gt; /path/log 查看关于 Linux 中重定向相关内容后怀疑可能于此有关
 &amp;gt;&amp;gt; 输出重定向到一个文件或设备 追加原来的文件
2&amp;gt;&amp;gt; 将一个标准错误输出重定向到一个文件或设备 追加到原来的文件
 随即修改 Cron 文件，将标准错误重定向到文件
1* * * * * php /path/artisan schedule:run 2&amp;gt;&amp;gt; /path/log 文件中打印出了错误信息</description>
    </item>
    
    <item>
      <title>Debian Ubuntu 更新内核并开启 TCP BBR 功能</title>
      <link>https://kouler.com/posts/debian-ubuntu%E6%9B%B4%E6%96%B0%E5%86%85%E6%A0%B8%E5%B9%B6%E5%BC%80%E5%90%AFtcp-bbr%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Sat, 16 Jun 2018 03:37:24 +0800</pubDate>
      
      <guid>https://kouler.com/posts/debian-ubuntu%E6%9B%B4%E6%96%B0%E5%86%85%E6%A0%B8%E5%B9%B6%E5%BC%80%E5%90%AFtcp-bbr%E5%8A%9F%E8%83%BD/</guid>
      <description>BBR (Bottleneck Bandwidth and RTT) 是 Google 提供的 TCP 拥塞控制算法，适用于复杂网络环境下的 TCP 加速。
 Debian 8.x 或者 Debian 9.x 系统，当然以下教程也适合 Ubuntu 14.04 或 Ubuntu 16.04 如果是虚拟机，那么得使用 KVM 或 Xen 等可以修改内核的平台，OpenVZ 方法我们不做介绍  升级内核 BBR 只支持 4.9.x 以上的内核，所以我们需要更新升级以下
如果你使用的是 Debian 9.x，那么这一步可以直接跳过，其他三个内核版本较旧的系统，我们可以使用 Ubuntu 打包好的内核安装包
首先，找到 4.9.x 以上版本的稳定内核，这里我们推荐使用 LTS 版本，目前最新的是 4.9.40 下载安装即可
1mkdir kernel-tmp &amp;amp;&amp;amp; cd kernel-tmp 2wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.9.88/linux-headers-4.9.88-040988_4.9.88-040988.201803181131_all.deb 3wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.9.88/linux-headers-4.9.88-040988-generic_4.9.88-040988.201803181131_amd64.deb 4wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.9.88/linux-image-4.9.88-040988-generic_4.9.88-040988.201803181131_amd64.deb 5sudo dpkg -i *.deb 安装完以后直接 reboot 重启，一切顺利的话请检查以下当前的内核版本
1root@debian ~ # uname -r 24.</description>
    </item>
    
    <item>
      <title>早期 IOS 设备强制恢复系统方法</title>
      <link>https://kouler.com/posts/%E6%97%A9%E6%9C%9Fios%E8%AE%BE%E5%A4%87%E5%BC%BA%E5%88%B6%E6%81%A2%E5%A4%8D%E7%B3%BB%E7%BB%9F%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 09 Apr 2018 21:41:39 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E6%97%A9%E6%9C%9Fios%E8%AE%BE%E5%A4%87%E5%BC%BA%E5%88%B6%E6%81%A2%E5%A4%8D%E7%B3%BB%E7%BB%9F%E6%96%B9%E6%B3%95/</guid>
      <description>关机后按住返回键 与电脑连接数据线 打开 iTunes 后自动弹出恢复,期间必须按住返回键  有误的官方做法</description>
    </item>
    
    <item>
      <title>无线路由器之间设置有线中继</title>
      <link>https://kouler.com/posts/%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B9%8B%E9%97%B4%E8%AE%BE%E7%BD%AE%E6%9C%89%E7%BA%BF%E4%B8%AD%E7%BB%A7/</link>
      <pubDate>Fri, 23 Mar 2018 01:39:15 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B9%8B%E9%97%B4%E8%AE%BE%E7%BD%AE%E6%9C%89%E7%BA%BF%E4%B8%AD%E7%BB%A7/</guid>
      <description> 第二个路由器关闭 DHCP 服务 WAN 口自动获取 IP 或者手动配制成第一个路由器的局域网 设置第二个路由器的密码，加密方式，ssid 和第一个一样，信道不能和第一个一样 第一个路由的 LAN 口进第二个路由的 LAN 口  </description>
    </item>
    
    <item>
      <title>版本号规范</title>
      <link>https://kouler.com/posts/%E7%89%88%E6%9C%AC%E5%8F%B7%E8%A7%84%E8%8C%83/</link>
      <pubDate>Sun, 11 Mar 2018 16:03:55 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E7%89%88%E6%9C%AC%E5%8F%B7%E8%A7%84%E8%8C%83/</guid>
      <description>版本号组成和范例 &amp;lt;主版本号&amp;gt;.&amp;lt;次版本号&amp;gt;.&amp;lt;修订号&amp;gt;-&amp;lt;先行版本号&amp;gt;+&amp;lt;版本编译信息&amp;gt;
# 主版本号+次版本号+修订号 范例： 0.1.0 1.0.0 1.0.9 1.10.0 # 主版本号+次版本号+修订号+先行版本号 范例： 1.0.0-alpha 1.0.0-alpha.1 1.0.0-0.3.7 1.0.0-x.7.z.92 # 主版本号+次版本号+修订号+先行版本号+版本编译信息 范例： 1.0.0-alpha+001 1.0.0+20130313144700 1.0.0-beta+exp.sha.5114f85 版本号中希腊字母标识 Alpha 版： 也叫 α 版，此版本主要是以实现软件功能为主，通常只在软件开发者内部交流，一般而言，该版本软件的 Bug 较多，需要继续修改。
Beta 版： 此版本相对于 α 版已经有了很大的改进，消除了严重的错误，但还是存在着一些缺陷，需要经过多次测试来进一步消除，此版本主要的修改对香是软件的 UI。
RC 版： （Release Candidate）发布候选版本，此版本已经相当成熟了，基本上不存在导致错误的 BUG，与即将发行的正式版相差无几，测试人员基本通过的版本。
Release 版： 此版本意味着最终版本、上线版本，在前面版本的一系列测试版之后，终归会有一个正式版本，是最终交付用户使用的一个版本。该版本有时也称为标准版。一般情况下，Release 不会以单词形式出现在软件封面上，取而代之的是符号 (R)。
版本号修改规则 主版本号： 当功能模块有较大的变动，比如增加多个模块或者整体架构发生变化。此版本号由项目决定是否修改。
次版本号： 当功能有一定的增加或变化，比如增加了对权限控制、增加自定义视图等功能。此版本号由项目决定是否修改。
修订号： 一般是 Bug 修复或是一些小的变动，要经常发布修订版，时间间隔不限，修复一个严重的bug即可发布一个修订版。此版本号由项目经理决定是否修改。
先行版本号： 被标上先行版本号则表示这个版本并非稳定而且可能无法达到兼容的需求。
版本编译信息： 可以记录修改项目的当前日期或编译信息，每天对项目的修改都需要更改日期版本号。版本编译信息不标识版本优先级，因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。
参考 &amp;amp; 扩展  语义化版本 2.0.0 APP版本号命名规范及原则  </description>
    </item>
    
    <item>
      <title>终端设置代理</title>
      <link>https://kouler.com/posts/%E7%BB%88%E7%AB%AF%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</link>
      <pubDate>Fri, 09 Mar 2018 10:46:39 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E7%BB%88%E7%AB%AF%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</guid>
      <description>设置和取消临时代理 临时代理在退出当前终端后失效
1# 设置临时 HTTP 代理 2export http_proxy=http://proxyAddress:port 3 4# 设置临时 SOCKS5 代理 5export ALL_PROXY=socks5://proxyAddress:port 6 7# SS 下的 HTTP 代理 8export http_proxy=http://127.0.0.1:1087 9 10# 取消临时代理 11unset http_proxy 12unset ALL_PROXY 参考 &amp;amp; 扩展  让终端走代理的几种方法  </description>
    </item>
    
    <item>
      <title>Golang 交叉编译</title>
      <link>https://kouler.com/posts/golang%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</link>
      <pubDate>Mon, 05 Mar 2018 18:28:42 +0800</pubDate>
      
      <guid>https://kouler.com/posts/golang%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</guid>
      <description>什么是跨平台交叉编译 交叉编译 通俗地讲就是在一种平台上编译出能运行在体系结构不同的另一种平台上的程序，比如在 PC 平台（X86 CPU）上编译出能运行在以 ARM 为内核的 CPU 平台上的程序，编译得到的程序在 X86 CPU 平台上是不能运行的，必须放到ARM CPU 平台上才能运行，虽然两个平台用的都是 Linux 系统。
交叉编译这种方法在异平台移植和嵌入式开发时非常有用。
本地编译 相对与交叉编译，平常做的编译叫本地编译，也就是在当前平台编译，编译得到的程序也是在本地执行。
用来编译跨平台程序的编译器就叫交叉编译器，相对来说，用来做本地编译的工具就叫本地编译器。
所以要生成在目标机上运行的程序，必须要用交叉编译工具链来完成。在裁减和定制 Linux 内核用于嵌入式系统之前，由于一般嵌入式开发系统存储大小有限，通常都要在性能优越的 PC 上建立一个用于目标机的交叉编译工具链，用该交叉编译工具链在 PC 上编译目标机上要运行的程序。
交叉编译工具链是一个由编译器、连接器和解释器组成的综合开发环境，交叉编译工具链主要由 binutils、gcc 和 glibc 3个部分组成。
有时出于减小 libc 库大小的考虑，也可以用别的 c 库来代替 glibc，例如 uClibc、dietlibc 和 newlib。
Golang 的跨平台交叉编译 Go 语言是编译型语言，可以将程序编译后在将其拿到其它操作系统中运行，此过程只需要在编译时增加对其它系统的支持。
交叉编译依赖下面几个环境变量  $GOARCH 目标平台（编译后的目标平台）的处理器架构（386、amd64、arm） $GOOS 目标平台（编译后的目标平台）的操作系统（darwin、freebsd、linux、windows）  各平台的 GOOS 和 GOARCH 参考    OS ARCH OS version     linux 386 / amd64 / arm &amp;gt;= Linux 2.</description>
    </item>
    
    <item>
      <title>迁移 Git 仓库</title>
      <link>https://kouler.com/posts/%E8%BF%81%E7%A7%BBgit%E4%BB%93%E5%BA%93/</link>
      <pubDate>Fri, 26 May 2017 13:21:15 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E8%BF%81%E7%A7%BBgit%E4%BB%93%E5%BA%93/</guid>
      <description>1// 切换到需要迁移的 Git 项目目录 2$ cd project 3 4// 添加 Git 远程仓库 5$ git remote add gitlab git@gitlab.com:team/name.git 6 7// 迁移代码到远程仓库 8$ git push -u gitlab master 参考 &amp;amp; 扩展阅读  如何把已存在的git项目转移到Gitlab项目 Git远程操作详解  </description>
    </item>
    
    <item>
      <title>SSH 动态端口转发</title>
      <link>https://kouler.com/posts/ssh%E5%8A%A8%E6%80%81%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</link>
      <pubDate>Fri, 26 May 2017 00:35:46 +0800</pubDate>
      
      <guid>https://kouler.com/posts/ssh%E5%8A%A8%E6%80%81%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</guid>
      <description>当我们在一个不安全的 WiFi 环境下上网，用 SSH 动态转发来保护我们的网页浏览及 MSN 信息无疑是十分必要的。
动态转发的命令格式：
1$ ssh -D &amp;lt;local port&amp;gt; &amp;lt;SSH Server&amp;gt; 这里 SSH 创建了一个 SOCKS 代理服务。我们可以直接使用 localhost:7001 来作为正常的 SOCKS 代理来使用，直接在浏览器或 MSN 上设置即可。在 SSH Client 端无法访问的网站现在也都可以正常浏览。而这里需要值得注意的是，此时 SSH 所包护的范围只包括从浏览器端（SSH Client 端）到 SSH Server 端的连接，并不包含从 SSH Server 端 到目标网站的连接。如果后半截连接的安全不能得到充分的保证的话，这种方式仍不是合适的解决方案。
SSH 隧道的搭建 首先需要有一台支持 SSH 的墙外服务器，此服务器只要能 SSH 连接即可。
客户端 SSH 执行如下命令：
1$ ssh -D 7001 username@remote-host 上述命令中 -D 表示动态绑定，7001 表示本地 SOCKS 代理的侦听端口，可以改成别的，后面的 username@remote-host 就是登录远程服务器的用户名和主机。当然，这个命令后会提示输入密码，就是 username 这个用户的密码（除非配置了SSH公钥认证，可以不输入密码）这样隧道就打通了！
最后在浏览器或者其他应用程序上设置 SOCKS 代理(设置 v4 的 SOCKS 就可以了，v5 的 SOCKS 增加了鉴权功能)，代理指向 127.</description>
    </item>
    
    <item>
      <title>复杂请求的跨域解决方法</title>
      <link>https://kouler.com/posts/%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 17 Feb 2017 19:22:38 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</guid>
      <description>简单请求遇到跨域问题时，只需要在服务器端设置响应头中加入允许跨域的头部信息即可。
当遇到复杂请求时，浏览器为了防止跨域请求无端对服务器数据造成损坏会先发送一个 Options 的预检请求。服务器应该对其进行处理，决定是否允许当前客户端进一步发起跨域请求。随后浏览器会根据 Options 请求的响应信息来决定是否进行下一步真实的请求。
服务器在此次 Options 请求的返回内容中还可以指示浏览器，是否在下次请求携带相关的 Cookie 或者 Http Authentication 数据过来。
什么是简单请求  仅使用 Get 方法的请求。 仅使用 Head 方法的请求。 仅使用 Content-Type 为 application/x-www-form-urlencoded、multipart/form-data 或 text/plain 发起的 Post 请求。  什么是复杂请求 不满足简单请求条件的都属于复杂请求。
解决复杂请求下的跨域问题 1&amp;lt;?php 2 3class CORSMiddleware 4{ 5 public function handle($request, Closure $next) 6 { 7 // 跨域请求时浏览器会先使用 options 方法判断是否允许当前域名发送跨域请求 8 $origin = isset($_SERVER[&amp;#39;HTTP_ORIGIN&amp;#39;]) ? $_SERVER[&amp;#39;HTTP_ORIGIN&amp;#39;] : &amp;#39;&amp;#39;; 9 10 $allow_origin = array( 11 &amp;#39;http://localhost:8888&amp;#39;, 12 &amp;#39;http://test.com&amp;#39;, 13 &amp;#39;https://test.</description>
    </item>
    
    <item>
      <title>Laravel 字段验证</title>
      <link>https://kouler.com/posts/laravel%E5%AD%97%E6%AE%B5%E9%AA%8C%E8%AF%81/</link>
      <pubDate>Sat, 17 Dec 2016 18:06:02 +0800</pubDate>
      
      <guid>https://kouler.com/posts/laravel%E5%AD%97%E6%AE%B5%E9%AA%8C%E8%AF%81/</guid>
      <description>手动创建验证程序示例 1&amp;lt;?php 2 3$data = [ 4 &amp;#39;email&amp;#39; = &amp;#39;aaa@gmail.com&amp;#39;, 5 &amp;#39;name&amp;#39;=&amp;#39;aaa&amp;#39;, 6 &amp;#39;password&amp;#39;=&amp;#39;aaa&amp;#39; 7]; 8 9$rules = array( 10 &amp;#39;email&amp;#39; =&amp;gt; &amp;#39;required|email&amp;#39;, 11 &amp;#39;name&amp;#39; =&amp;gt; &amp;#39;required|between:1,20&amp;#39;, 12 &amp;#39;password&amp;#39; =&amp;gt; &amp;#39;required|min:8&amp;#39;, 13); 14 15$message = array( 16 &amp;#39;required&amp;#39; =&amp;gt; &amp;#39;:attribute 不能为空&amp;#39;, 17 &amp;#39;between&amp;#39; =&amp;gt; &amp;#39;:attribute 长度必须在 :min 和 :max 之间&amp;#34; 18); 1920$attributes = array( 21&amp;#39;email&amp;#39; =&amp;gt; &amp;#39;电子邮件&amp;#39;, 22&amp;#39;name&amp;#39; =&amp;gt; &amp;#39;用户名&amp;#39;, 23&amp;#39;password&amp;#39; =&amp;gt; &amp;#39;用户密码&amp;#39;, 24); 25 26$validate = Validator::make($data,$rules,$message,$attributes); 27 28var_dump($validate-&amp;gt;fails()); 29var_dump($validate-&amp;gt;messages()); 30var_dump($validate-&amp;gt;messages()-&amp;gt;first()) Validator 的验证扩展 1&amp;lt;?</description>
    </item>
    
    <item>
      <title>macOS 下开启显示器 HiDPI 方法</title>
      <link>https://kouler.com/posts/macos%E4%B8%8B%E5%BC%80%E5%90%AF%E6%98%BE%E7%A4%BA%E5%99%A8hidpi%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 23 Nov 2016 10:21:42 +0800</pubDate>
      
      <guid>https://kouler.com/posts/macos%E4%B8%8B%E5%BC%80%E5%90%AF%E6%98%BE%E7%A4%BA%E5%99%A8hidpi%E6%96%B9%E6%B3%95/</guid>
      <description>备份文件 In Google Cloud
系统环境 操作系统：MacOS
显示器型号：DELL2515H
显示器分辨率：2560 * 1440 2K
MacOS系统获取系统权限方法 MacOS系统下，某些系统文件夹只有系统有权限读写，称为System Integrity Protection（SIP），需要提前关闭。
创建相应文件夹和文件 首先在终端获取显示器的 DisplayVendorID 和 DisplayProductID。
1# 获取显示器 DisplayVendorID 2ioreg -l | grep &amp;#34;DisplayVendorID&amp;#34; 3 4# 获取显示器 DisplayProductID 5ioreg -l | grep &amp;#34;DisplayProductID&amp;#34; 在桌面新建一个文件夹，名称格式为 DisplayVendorID-xxxx，其中 xxxx 为显示器 DisplayVendorID 的16进制小写
在刚创建的文件夹中新建空白文件，名称格式为 DisplayProductID-xxxx，其中 xxxx 为显示器 DisplayProductID 的16进制小写
以上步骤可使用脚本 patch-edid.rb 自动生成。
生成步骤：
 下载或手动创建文件 patch-edid.rb 到桌面目录 打开终端进入桌面目录 执行命令 ruby patch-edid.rb 脚本会在桌面目录创建好文件夹和文件（文件内容也有，但可能没有效果）  编辑新建的文件 &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.</description>
    </item>
    
    <item>
      <title>macOS 无法获得权限问题</title>
      <link>https://kouler.com/posts/macos%E6%97%A0%E6%B3%95%E8%8E%B7%E5%BE%97%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 20 Nov 2016 22:40:40 +0800</pubDate>
      
      <guid>https://kouler.com/posts/macos%E6%97%A0%E6%B3%95%E8%8E%B7%E5%BE%97%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/</guid>
      <description>通常情况下，在命令行中使用 sudo 命令便可以以 Root 用户执行命令
在 MacOS 中，某些系统文件夹下，即使使用 sudo 命令也无法获得 Root 权限，这被称为 System Integrity Protection（SIP）
要想关闭 SIP，需要进入 Recover 模式下设置，具体方法如下：
 重启电脑，开机时按住 Command + r 键进入 Recover 模式 在工具中找到 Terminal 命令行终端 在命令行中输入命令 csrutil disable 重新启动后 SIP 就被关闭了  如需重新打开 SIP 保护，操作步骤一样，执行命令为 csrutil enable</description>
    </item>
    
    <item>
      <title>Lumen 问题汇总</title>
      <link>https://kouler.com/posts/lumen%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</link>
      <pubDate>Wed, 19 Oct 2016 11:42:41 +0800</pubDate>
      
      <guid>https://kouler.com/posts/lumen%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</guid>
      <description>lumen 安装在子目录下时访问首页出现404错误 public/index.php 中的
1&amp;lt;?php 2 3$app-&amp;gt;run(); 改为
1&amp;lt;?php 2 3$app-&amp;gt;run($app[&amp;#39;request&amp;#39;]); lumen 配置数据库  在根目录添加 .env 配置文件并修改数据库信息 app.php 文件中去掉 Dotenv::load(__DIR__ . &#39;/../&#39;);行的注释，只有去掉才可以使用env配置文件 控制器文件中通过 app 函数来调用数据库，例： $result = app(&#39;db&#39;)-&amp;gt;select(&amp;quot;select * from xay_waiter&amp;quot;);  详细信息
使用 Session  开启Facades，开启方式是去掉 bootstrap/app.php 中 $app-&amp;gt;withFacades(); 的注释。 开启 Session，开启方式：去掉 bootstrap/app.php 中 $app-&amp;gt;middleware(); 的 StartSession 中间件的注释。 使用时发生错误：Class &amp;lsquo;Memcached&amp;rsquo; not found ，因为在 .env 文件中，Session 的默认驱动是：memcached。修改即可。 目前支持的驱动有：file、cookie、database、memcached、redis、array。   Session::put(&#39;key&#39;, &#39;value&#39;); // 保存对象到 Session 中 $value = Session::get(&#39;key&#39;); // 从 Session 取回对象 $value = Session::pull(&#39;key&#39;, &#39;default&#39;); // 从 Session 取回对象并删除 $data = Session::all(); // 从 Session 取出所有对象 Session::has(&#39;users&#39;); // 判断对象在 Session 中是否存在 Session::forget(&#39;key&#39;); // 从 Session 中移除对象 Session::flush(); // 清空所有 Session    lumen 发送邮件  在 composer.</description>
    </item>
    
    <item>
      <title>RESTful 设计风格中的 HTTP 状态码含义</title>
      <link>https://kouler.com/posts/restful%E8%AE%BE%E8%AE%A1%E9%A3%8E%E6%A0%BC%E4%B8%AD%E7%9A%84http%E7%8A%B6%E6%80%81%E7%A0%81%E5%90%AB%E4%B9%89/</link>
      <pubDate>Wed, 19 Oct 2016 11:35:15 +0800</pubDate>
      
      <guid>https://kouler.com/posts/restful%E8%AE%BE%E8%AE%A1%E9%A3%8E%E6%A0%BC%E4%B8%AD%E7%9A%84http%E7%8A%B6%E6%80%81%E7%A0%81%E5%90%AB%E4%B9%89/</guid>
      <description>状态码 类型 含义     100 ~ 消息 代表请求已被接受，需要继续处理   200 ~ 成功 代表请求已成功被服务器接收、理解、并接受   300 ~ 重定向 代表需要客户端采取进一步的操作才能完成请求   400 ~ 请求错误 代表了客户端看起来可能发生了错误，妨碍了服务器的处理   500 ~ 服务器错误 代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理   600 ~ 服务器错误 代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理        状态代码 状态信息 含义 适用情况 对应懒喵项目错误号     100 Continue 初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新）     101 Switching Protocols 服务器将遵从客户的请求转换到另外一种协议（HTTP 1.</description>
    </item>
    
    <item>
      <title>浏览器提示检测到了网络变化解决方法</title>
      <link>https://kouler.com/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%90%E7%A4%BA%E6%A3%80%E6%B5%8B%E5%88%B0%E4%BA%86%E7%BD%91%E7%BB%9C%E5%8F%98%E5%8C%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 19 Oct 2016 11:25:02 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%90%E7%A4%BA%E6%A3%80%E6%B5%8B%E5%88%B0%E4%BA%86%E7%BD%91%E7%BB%9C%E5%8F%98%E5%8C%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</guid>
      <description>问题 会有 ERR_CERT_DATABASE_CHANGED 与 NETWORK CHANGED 的提示。有时候会自动立刻刷新重载。 大部分 HTTPS 内的 AJAX 请求很多都发送失败，导致页面无法正常使用。
解决方法 和 com.alipay.DispatcherService 支付宝插件有关 命令行中使用命令
1$ sudo launchctl remove com.alipay.DispatcherService 停掉支付宝服务就没有这个问题了
参考 &amp;amp; 扩展阅读  MacOS Sierra 升级 CHROME 用 HTTPS 访问间歇性失败  </description>
    </item>
    
    <item>
      <title>浏览器拦截第三方 Cookies 解决方法</title>
      <link>https://kouler.com/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8B%A6%E6%88%AA%E7%AC%AC%E4%B8%89%E6%96%B9cookies%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 13 Oct 2016 12:09:37 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8B%A6%E6%88%AA%E7%AC%AC%E4%B8%89%E6%96%B9cookies%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</guid>
      <description>高版本的 Safari 浏览器为了保护用户隐私会默认阻止第三方的 Cookies。Web 开发中，使用第三方资源非常常见，大多数情况下，这并不会带来问题。然而当我们希望能读写第三方域下的 Cookies 时，就会遇到 Cookies 被拦截的情况从而导致各种问题。
第三方指的是谁 当用户请求某一域名下的页面时，如果页面中引用了另一个域名下的资源，则另一个域名被算作第三方。
解决第三方 Cookies 被拦截的方法 方法一: 客户端手动修改设置。例如 Safari 可以通过偏好设置中的隐私栏修改 Cookies 的安全策略。
方法二: 将需要请求的第三方资源放在本域下。
前两种方法有各自的限制，如果无法解决问题，则需要考虑更复杂的解决方法。
方法三: Safari 会在第三方域下完全没有 Cookies 时阻止第三方 Cookies，而第三方域下只要有过任意一个 Cookie，即可顺利读写。 据此，我们可以考虑当第三方域下没有 Cookies 时，首先将页面先跳到这个域，写入任意 Cookies，再跳回来。或者弹出一个新窗口，写入 Cookies，再关闭弹窗。
方法四: Safari 只阻止了第三方 Cookies，并没有阻止第三方 LocalStorage，于是，我们便可以使用更为激进的方案，即放弃第三方 Cookies，使用 LocalStorage 来代替。
参考 &amp;amp; 扩展阅读  当浏览器默认禁用第三方cookie  </description>
    </item>
    
    <item>
      <title>PHP 中获取 POST 数据的方式</title>
      <link>https://kouler.com/posts/php%E4%B8%AD%E8%8E%B7%E5%8F%96post%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Tue, 13 Sep 2016 18:42:34 +0800</pubDate>
      
      <guid>https://kouler.com/posts/php%E4%B8%AD%E8%8E%B7%E5%8F%96post%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F/</guid>
      <description>form-data x-www-form-urlencoded raw     $_POST 推荐 推荐 无效   $GLOBALS[&amp;lsquo;HTTP_RAW_POST_DATA&amp;rsquo;] 无效 无效 有效   php://input 无效 有效 推荐    $_POST 方式 通过 HTTP POST 方法传递的变量组成的数组。是自动全局变量。
Coentent-Type 仅在取值为 application/x-www-data-urlencoded 或 multipart/form-data 两种情况下，PHP才会将 HTTP 请求数据包中相应的数据填入全局变量 $_POST。
$GLOBALS[&amp;lsquo;HTTP_RAW_POST_DATA&amp;rsquo;] 方式 此变量仅在碰到未识别 MIME 类型的数据时产生。
PHP 默认识别的数据类型是 application/x-www.form-urlencoded 标准的数据类型。如果 POST 过来的数据不是 PHP 能够识别的，比如 text/xml 或者 soap 等可以用 $GLOBALS[&amp;lsquo;HTTP_RAW_POST_DATA&amp;rsquo;]方式来接收。
不过，访问原始 POST 数据的更好方法是 php://input。
php://input 方式 php://input 允许读取 POST 的原始数据。和 $HTTP_RAW_POST_DATA 比起来，它给内存带来的压力较小，并且不需要任何特殊的 php.</description>
    </item>
    
    <item>
      <title>PhpStorm 常用快捷键</title>
      <link>https://kouler.com/posts/phpstorm%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</link>
      <pubDate>Tue, 21 Jun 2016 00:38:50 +0800</pubDate>
      
      <guid>https://kouler.com/posts/phpstorm%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid>
      <description>文本编辑    快捷键 描述     Command + Alt + I 对当前文件进行格式化排版   Control + G 顺序选中相同的文本   Shift + Enter 在当前行下方插入新行   Command + Alt + Enter 在当前行上方插入新行   Command + / 单行注释   Command + Shift + / 块代码注释   Command + D 复制当前行   Command + P 查看当前函数参数   Command + Shift + Enter 补全代码（if）   Alt + / 自动完成   Alt + Click 插入多个光标（鼠标单击）   Alt Alt + Up 向上插入多个光标（双击 Alt 并按住）   Alt Alt + Down 向下插入多个光标（双击 Alt 并按住）   Alt + Double Click 选中多个文本（鼠标双击）   Alt + Mouse 选中多个文本（鼠标拖动）   Ctrl + Mouse 复制选中文本（鼠标拖动）   Command + Mouse 移动选中文本（鼠标拖动）   Command + J 活动代码提示   Command + Alt + T 插入环绕代码   Command + .</description>
    </item>
    
    <item>
      <title>WebServer 和 CGI 以及 PHPFPM 之间的关系</title>
      <link>https://kouler.com/posts/webserver%E5%92%8Ccgi%E4%BB%A5%E5%8F%8Aphpfpm%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Wed, 15 Jun 2016 23:28:36 +0800</pubDate>
      
      <guid>https://kouler.com/posts/webserver%E5%92%8Ccgi%E4%BB%A5%E5%8F%8Aphpfpm%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</guid>
      <description>WebServer 最早的 Web服务器简单地响应浏览器发来的 HTTP 请求，并将存储在服务器上的 HTML 文件返回给浏览器，也就是静态HTML。
但事物总是不断发展的，网站也逐渐变得复杂，所以出现动态技术。但是 Web服务器并不能直接运行 php，asp 这样的文件，当浏览器请求 index.php?a=1&amp;amp;b=2 时，Web服务器就不知道该如何处理了，它不能理解 “php”、“?”、“&amp;amp;”、“a”、“b” 各是什么意思，这时它就需要调用相应的脚本解释程序（如PHP-CGI）来处理这样的请求。
CGI Web服务器不知道如何处理动态页面请求，需要移交其他程序来处理，这时需要与该程序做个约定，我给你什么，然后你给我什么，就是我把请求参数（如 a=1，b=2）发送给你，然后我接收你的处理结果给客户端。那这个约定就是 Common Gateway Interface，简称 CGI。这个协议可以用 VB，C，PHP，Python 等语言来实现。
CGI 只是接口协议，根本不是什么语言。
WebServer 与 CGI 程序的交互 Web服务器将根据 CGI程序的类型决定数据向 CGI程序的传送方式，通常是通过标准输入/输出流和环境变量来传递。
CGI程序通过标准输入（STDIN）和标准输出（STDOUT）来进行输入输出。此外 CGI程序还通过环境变量来得到输入。
操作系统提供了许多环境变量，它们定义了程序的执行环境，应用程序可以存取它们。
Web服务器和 CGI接口又另外设置了一些环境变量，用来向 CGI程序传递一些重要的参数。
下面是一些常用的 CGI 环境变量：
   变量名 描述     CONTENT_TYPE 这个环境变量的值指示所传递来的信息的MIME类型   CONTENT_LENGTH 如果服务器与 CGI 程序信息的传递方式是 POST，这个环境变量即是从标准输入 STDIN中可以读到的有效数据的字节数。这个环境变量在读取所输入的数据时必须使用   HTTP_COOKIE 客户机内的 COOKIE 内容   HTTP_USER_AGENT 提供包含了版本数或其他专有数据的客户浏览器信息   PATH_INFO 这个环境变量的值表示紧接在 CGI 程序名之后的其他路径信息。它常常作为 CGI 程序的参数出现   QUERY_STRING 如果服务器与 CGI 程序信息的传递方式是 GET，这个环境变量的值即使所传递的信息。这个信息经跟在CGI程序名的后面，两者中间用一个问号分隔   REMOTE_ADDR 这个环境变量的值是发送请求的客户机的 IP 地址，它是 WEB客户机需要提供给 WEB服务器的唯一标识，可以在 CGI 程序中用它来区分不同的 Web客户机   REMOTE_HOST 这个环境变量的值包含发送 CGI 请求的客户机的主机名。如果不支持你想查询，则无需定义此环境变量   REQUEST_METHOD 提供脚本被调用的方法。对于使用 HTTP/1.</description>
    </item>
    
    <item>
      <title>Linux0.11 内核引导启动流程</title>
      <link>https://kouler.com/posts/linux011%E5%86%85%E6%A0%B8%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Fri, 10 Jun 2016 22:36:02 +0800</pubDate>
      
      <guid>https://kouler.com/posts/linux011%E5%86%85%E6%A0%B8%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid>
      <description>计算机加电后，最开始 BIOS 中的程序会先开始执行，BIOS 程序执行结束后，将由操作系统接管。
引导启动过程中会用到的内核文件说明 boot / bootsect.s : 该程序是磁盘引导块程序，编译后会驻留在磁盘的第一个扇区中（即引导扇区中，0 磁道（柱面），0 磁头，第一个扇区）。计算机机加电 ROM BIOS 自检后，将被 BIOS 加载到内存 0x7C00 处执行。
boot / setup.s : 该程序主要用于读取机器的硬件配置参数，并把内核模块 system 移动到适当的内存位置处。
boot / head.s : 该程序会被编译连接在 system 模块的最前部分，主要进行硬件设备的探测设置和内存管理页面的初始化设置工作。
引导启动过程中文件运行顺序图 BIOS 程序执行流程  计算机加电，80x86 结构的 CPU 自动进入实模式，并从地址 0xFFFF0 开始自动执行代码。这个地址也就是 ROM-BIOS 中的地址。 BIOS 执行系统检测，并在物理地址 0 处初始化中断向量。 BIOS 将可启动设备的第一个扇区（磁盘引导扇区，512字节）读入内存绝对地址 0x7C00 处并跳转到这个地方。  接下来将由操作系统文件接管启动流程。
操作系统程序执行流程 Linux 的最最前面部分是用 8086 汇编语言编写的（bootsect.s）。它由 BIOS 读入到内存绝对地址 0x7C00（31KB）处。
 bootsect.s 执行时会把自己移动到内存绝对地址 0x90000（576KB）处。 bootsect.s 将启动设备中后 2KB 字节代码（setup.</description>
    </item>
    
    <item>
      <title>Bash 命令行快捷键</title>
      <link>https://kouler.com/posts/bash%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/</link>
      <pubDate>Mon, 23 May 2016 22:45:49 +0800</pubDate>
      
      <guid>https://kouler.com/posts/bash%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid>
      <description>编辑命令 Ctrl + a ：移到命令行首 Ctrl + e ：移到命令行尾 Ctrl + f ：按字符前移（右向） Ctrl + b ：按字符后移（左向） Ctrl + xx：在命令行首和光标之间移动 Ctrl + u ：从光标处删除至命令行首 Ctrl + k ：从光标处删除至命令行尾 Ctrl + d ：删除光标后的字符 Ctrl + h ：删除光标前的字符 Bang (!) 命令 !!： 执行上一条命令 !blah： 执行最近的以 blah 开头的命令，如 !ls !blah:p：仅打印输出，而不执行 !$： 上一条命令的最后一个参数，与 Alt + . 相同 !$:p： 打印输出 !$ 的内容 !*： 上一条命令的所有参数 !*:p： 打印输出 !* 的内容 ^blah： 删除上一条命令中的 blah ^blah^foo： 将上一条命令中的 blah 替换为 foo ^blah^foo^： 将上一条命令中所有的 blah 都替换为 foo 参考 &amp;amp; 扩展阅读  让你提升命令行效率的 Bash 快捷键  </description>
    </item>
    
    <item>
      <title>跨域问题解决方法</title>
      <link>https://kouler.com/posts/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 23 May 2016 17:35:00 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</guid>
      <description>本文通过设置 Access-Control-Allow-Origin 来实现跨域。 例如：客户端的域名是 client.com，而请求的域名是 server.com。 如果直接使用 ajax 访问，会有以下错误：
XMLHttpRequest cannot load http://server.com/server.php. No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;http://client.com&#39; is therefore not allowed access. 允许单个域名访问 指定某域名（ http://client.com ）跨域访问，则只需在 http://server.com/server.php 文件头部添加如下代码：
1&amp;lt;?php 2 3header(&amp;#39;Access-Control-Allow-Origin: http://client.com&amp;#39;); 允许多个域名访问 指定多个域名（ http://client1.com, http://client2.com 等 ）跨域访问，则只需在 http://server.com/server.php 文件头部添加如下代码：
1&amp;lt;?php 2 3$origin = isset($_SERVER[&amp;#39;HTTP_ORIGIN&amp;#39;])? $_SERVER[&amp;#39;HTTP_ORIGIN&amp;#39;] : &amp;#39;&amp;#39;; 4 5$allow_origin = array( 6 &amp;#39;http://client1.com&amp;#39;, 7 &amp;#39;http://client2.com&amp;#39; 8); 9 10if(in_array($origin, $allow_origin)){ 11 header(&amp;#39;Access-Control-Allow-Origin: &amp;#39;.$origin); 12} 允许所有域名访问 允许所有域名访问则只需在 http://server.</description>
    </item>
    
    <item>
      <title>PHP 中的二进制安全</title>
      <link>https://kouler.com/posts/php%E4%B8%AD%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/</link>
      <pubDate>Sat, 14 May 2016 21:47:46 +0800</pubDate>
      
      <guid>https://kouler.com/posts/php%E4%B8%AD%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/</guid>
      <description>二进制安全是什么 先看一段代码：
1&amp;lt;?php 2 3$string1 = &amp;#34;Hello&amp;#34;; 4$string2 = &amp;#34;Hello\0Hello&amp;#34;; 5 6// 返回0, 由于是非二进制安全，误判为相等 7echo strcoll($string1, $string2); 8 9// 返回&amp;lt;0,不相等 10echo strcmp($string1, $string2); 这是为什么呢？PHP 是基于 C 实现的，PHP 代码都会被 Zend引擎编译成 opcode，最终作为 C语言去执行。而对于 C语言中 &amp;ldquo;\0&amp;rdquo; 是字符串的结束符，它读到 &amp;ldquo;\0&amp;rdquo; 就会默认字符读取已经结束，从而抛掉后面的字符串。
1main(){ 2 char ab[] = &amp;#34;Hello&amp;#34;; 3 char ac[] = &amp;#34;Hello\0Hello&amp;#34;; 4 5 // 返回0, 由于是非二进制安全，误判为相等 6 strcmp(ab, ac); 7} 有一个二进制安全的定义:
 程序不会对其中的数据做任何限制、过滤、或者假设 —— 数据在写入时是什么样的，它被读取时就是什么样。
 PHP是如何实现二进制安全的 既然 PHP 是基于 C 实现的，C 字符串类型不是二进制安全的，PHP 又是如何实现的呢？这就是数据结构的功劳了。 PHP 的内核中，是如此定义字符串类型的</description>
    </item>
    
    <item>
      <title>PHP 中的异常捕获</title>
      <link>https://kouler.com/posts/php%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/</link>
      <pubDate>Thu, 12 May 2016 19:17:55 +0800</pubDate>
      
      <guid>https://kouler.com/posts/php%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/</guid>
      <description>PHP 中 try catch 可以帮助我们捕获程序代码的异常以便使我们很好的处理一些不必要的错误。
Try 语句 try 是用来定义检测异常的代码块。 需要进行异常处理的代码都必须放入 try 代码块内，以便捕获可能存在的异常。 每一个 try 至少要有一个与之对应的 catch 。
1&amp;lt;?php 2 3try { 4 // 需要进行异常处理的代码 5} try 代码块有可能运行到最后一行，也有可能抛出异常，如果抛出了异常，代码的剩余部分就会被跳过，程序会跳到 Catch 语句块中执行。
Catch 语句 定义处理发生异常时执行的代码块。使用多个 catch 可以捕获不同的类所产生的异常。
当 try 代码块不再抛出异常或者找不到 catch 能匹配所抛出的异常时，PHP 代码就会在跳转到最后一个 catch 的后面继续执行。 PHP允许在 catch 代码块内再次抛出（throw）异常。
当一个异常被抛出时，其后（指抛出异常时所在的代码块）的代码将不会继续执行，而 PHP 就会尝试查找第一个能与之匹配的 catch。
如果一个异常没有被捕获，而且又没用使用 set_exception_handler() 作相应的处理的话，那么 PHP 将会产生一个严重的错误，并且输出 Uncaught Exception ... （未捕获异常）的提示信息。
1&amp;lt;?php 2 3catch(Exception $e) { 4 echo $e; 5} 上面代码中，$e 是 Exception 类的一个实例。</description>
    </item>
    
    <item>
      <title>Linux 的中断异常和信号</title>
      <link>https://kouler.com/posts/linux%E7%9A%84%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E5%92%8C%E4%BF%A1%E5%8F%B7/</link>
      <pubDate>Tue, 19 Apr 2016 21:42:10 +0800</pubDate>
      
      <guid>https://kouler.com/posts/linux%E7%9A%84%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E5%92%8C%E4%BF%A1%E5%8F%B7/</guid>
      <description>中断 中断是指CPU对系统发生的某个事件作出的一种反应，让CPU暂时停止当前程序的执行转而执行处理新情况的程序和执行过程。即在程序运行过程中，系统出现了一个必须由CPU立即处理的情况，此时，CPU暂时中止程序的执行转而处理这个新的情况的过程就叫做中断。
中断向量: 每个中断和异常是由0~255之间的一个数来标识。Intel把这个8位的无符号整数叫做一个向量。
IRQ: 每个能够发出中断请求的硬件设备控制器都有一条名为IRQ的输出线。所有现有的IRQ线都与一个名为可编程中断控制器的硬件电路的输入引脚相连。
PIC: 可编程中断控制器
IDT: 中断描述符表，中断描述符表是一个系统表，它与每一个中断或异常向量相联系，每一个向量在表中有相应的中断和异常处理程序的入口地址。表中的每一项对应一个中断或异常向量，每个向量由8个字节组成。因此，最多需要256*8=2048字节来存放IDT。
广义的中断包含异步中断和同步中断。
异步中断 异步中断(外部中断/硬件中断)通常被直接称为中断(interrupt)
CPU对其的响应完全是被动的，但是可以屏蔽掉。
异步中断可分为可屏蔽中断（Maskable interrupt）和非屏蔽中断（Nomaskable interrupt）。
所谓的异步指的是发生的中断不是随正在执行的指令同步发生的，是由其他硬件设备依照 CPU 时钟信号随机产生的，是不可预知的，例如用户随时在键盘上按下一个键。
同步中断 同步中断(内部中断/软件中断)通常被称为异常(exception)
在Intel的手册中，同步中断被称之为异常。
异常可分为故障(fault)、陷阱(trap)、**终止(abort)**三类。
   类型 原因 异步/同步 返回行为 例子     陷阱 有意的异常 同步 总是返回到下一条指令 系统调用、信号机制 ( 通过软中断实现 )   故障 潜在可恢复的错误 同步 返回到当前指令 缺页异常、除 0 错误、段错误   终止 不可恢复的错误 同步 不会返回 硬件错误    软中断和硬中断 软中断是通信进程之间用来模拟硬中断的一种信号通信方式。是属于一种编程手段，也有称之为软中断通信机制。
硬中断一般就是指的硬件中断，也就是常说的中断，由硬件触发。
区别    类型 产生的位置 发生的时刻 时序     中断 CPU外部 随机 异步   异常 CPU内部 一条指令终止后 同步    信号机制 信号是异步的进程间的通讯机制，是在软件层次上对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。</description>
    </item>
    
    <item>
      <title>PhpStorm 下配置调试环境</title>
      <link>https://kouler.com/posts/phpstorm%E4%B8%8B%E9%85%8D%E7%BD%AE%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Wed, 06 Apr 2016 14:42:30 +0800</pubDate>
      
      <guid>https://kouler.com/posts/phpstorm%E4%B8%8B%E9%85%8D%E7%BD%AE%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/</guid>
      <description>使用 brew 安装 php 和 xdebug
PHP xdebug 配置信息
1[xdebug] 2; xdebug.remote_autostart=1 3zend_extension=&amp;#34;/usr/local/Cellar/php71-xdebug/2.5.5/xdebug.so&amp;#34; 4xdebug.remote_enable=1 5xdebug.remote_handler=&amp;#34;dbgp&amp;#34; 6xdebug.remote_host=localhost 7xdebug.remote_port=9001 8xdebug.idekey=&amp;#34;PHPSTORM&amp;#34; 9xdebug.profiler_enable_trigger=1 10xdebug.profiler_output_dir=&amp;#34;/Users/kouler/Codes/php/xdebug_profiler&amp;#34; 需要注意 xdebug 和 phpfpm 的默认端口都是 9000，端口冲突
参考 &amp;amp; 扩展  在Mac上的PHPSTORM配置XDebug来调试PHP程序 PHP:使用xdebug profiler 做性能分析  </description>
    </item>
    
    <item>
      <title>PostgreSQL 常用操作</title>
      <link>https://kouler.com/posts/postgresql%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sun, 03 Apr 2016 12:21:24 +0800</pubDate>
      
      <guid>https://kouler.com/posts/postgresql%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</guid>
      <description>增删改查 SQL 语句 1-- 插入数据 2INSERT INTO user_tbl(name, signup_date) VALUES(&amp;#39;张三&amp;#39;, &amp;#39;2013-12-22&amp;#39;); 3 4-- 查询记录 5SELECT * FROM user_tbl; 6 7-- 更新数据 8UPDATE user_tbl set name = &amp;#39;李四&amp;#39; WHERE name = &amp;#39;张三&amp;#39;; 9 10-- 删除记录 11DELETE FROM user_tbl WHERE name = &amp;#39;李四&amp;#39; ; 批量更新 SQL 语句 1-- 批量更新一个字段 2UPDATE mytable 3SET myfield = CASE id 4 WHEN 1 THEN &amp;#39;value&amp;#39; 5 WHEN 2 THEN &amp;#39;value&amp;#39; 6 WHEN 3 THEN &amp;#39;value&amp;#39; 7END 8WHERE id IN (1,2,3) 9 10-- 批量更新多个字段 11UPDATE categories 12SET display_order = CASE id 13 WHEN 1 THEN 3 14 WHEN 2 THEN 4 15 WHEN 3 THEN 5 16END, 17title = CASE id 18 WHEN 1 THEN &amp;#39;New Title 1&amp;#39; 19 WHEN 2 THEN &amp;#39;New Title 2&amp;#39; 20 WHEN 3 THEN &amp;#39;New Title 3&amp;#39; 21END 22WHERE id IN (1,2,3) 序列操作 SQL 语句 1-- 查看当前序列的值 2SELECT currval(&amp;#39;user_id_seq&amp;#39;); 3 4-- 设置序列的初始值为 100 5select setval(&amp;#39;user_id_seq&amp;#39;,100); 6 7-- 递增序列的值并返回 8select nextval(&amp;#39;user_id_seq&amp;#39;); 查询 SQL 语句 1-- 转换时间戳为格式化时间函数 TO_TIMESTAMP() 2SELECT TO_TIMESTAMP(created_at) FROM user; 3 4-- 转换时间戳为格式化时间函数 TO_TIMESTAMP() ，显示为中国时区 5-- 使用 &amp;#39;CST&amp;#39; 时区不一定显示为中国本地时间，建议使用 &amp;#39;Asia/Shanghai&amp;#39; 时区 6SELECT TO_TIMESTAMP(created_at) AT TIME ZONE &amp;#39;CST&amp;#39; FROM user; 7SELECT TO_TIMESTAMP(created_at) AT TIME ZONE &amp;#39;Asia/Shanghai&amp;#39; FROM user; 8 9-- 返回字段中的条件判断 10SELECT name, CASE sex WHEN 1 THEN &amp;#39;男&amp;#39; WHEN 2 THEN &amp;#39;女&amp;#39; ELSE &amp;#39;保密&amp;#39; END AS sex, age FROM user; 11 12-- 拼接字符串 13SELECT CONCAT(&amp;#39;姓名:&amp;#39;, name) AS name, age FROM user; 14 15-- 数值计算 16SELECT id, amount/100 FROM order; 17 18-- 保留 2 位小数精度 19SELECT id, round(100/3, 2) FROM order; 20 21-- 解析数组格式数据，获取数据时先将数组转为 JSON，再用编程语言函数将 JSON 转为可识别格式，例如 PHP 中的 json_decode() 22SELECT array_to_json(ids) FROM user; Schema 操作 SQL 语句 1-- 创建新表 2CREATE TABLE user_tbl(name VARCHAR(20), signup_date DATE); 3 4-- 添加字段 5ALTER TABLE user_tbl ADD email VARCHAR(40); 6ALTER TABLE user_tbl ADD COLUMN images jsonb DEFAULT &amp;#39;{}&amp;#39;; 7 8-- 更改字段类型 9ALTER TABLE user_tbl ALTER COLUMN signup_date SET NOT NULL; 10 11-- 更改字段类型长度 12ALTER TABLE user_tbl ALTER COLUMN password TYPE varchar(32); 13 14-- 为字段添加索引 15CREATE INDEX index_name ON user_tbl (name); 16 17-- 设置字段默认值（注意字符串使用单引号） 18ALTER TABLE user_tbl ALTER COLUMN email SET DEFAULT &amp;#39;example@example.</description>
    </item>
    
    <item>
      <title>PostgreSQL 中 JSON 和 JSONB 的区别</title>
      <link>https://kouler.com/posts/postgresql%E4%B8%ADjson%E5%92%8Cjsonb%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 02 Apr 2016 15:47:06 +0800</pubDate>
      
      <guid>https://kouler.com/posts/postgresql%E4%B8%ADjson%E5%92%8Cjsonb%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>Postgres 中的 Json 和 Jsonb 数据类型都是用于储存 JSON ( JavaScript Object Notation ) 格式数据。虽然 Text 数据类型也可以用来储存 JSON 数据， 但 JSON 数据类型的优势在于它会根据 JSON 规则来强制要求每个被储存的值都是合法的 JSON 数据。
一般情况下， 除非有特别的要求（比如针对对象键排列顺序的遗留假设，legacy assumption）， 否则的话， 大多数应用程序都应该优先使用 jsonb 类型来储存 JSON 数据。
Json 数据类型 json 数据类型储存输入文本的精确拷贝，处理函数在每次执行的时候，都必须对这些文本重新进行分析。
json 数据类型会保留文本中与 Json 语义完全无关的空白字符，各个键在 Json 对象内的排列顺序以及具有相同键的值。
Jsonb 数据类型 Jsonb 数据类型以无压缩（decomposed）二进制格式来储存数据，因为格式转换带来的花销，这种类型在处理输入的时候速度会稍微慢一些，但是因为这种类型的数据并不需要重新进行分析，所以这种数据的处理速度会明显地快很多。
jsonb 支持索引特性，这是一个明显的优点。
jsonb 不会保留任何无关的空白，不会保留对象键的排列顺序，也不会保留任何重复的对象键。如果输入里面指定了重复的键，那么只有最后一个值会被保留。
jsonb 类型可以检测一个 jsonb 值是否包含了另一个 jsonb 值，而 json 类型并不具备这样的特性。
jsonb 会拒绝那些超出 PostgreSQL 数字类型范围的数字，而 json 则不会这样做。
参考 &amp;amp; 扩展  JSON 类型 JSON Functions and Operators PostgreSQL 9.</description>
    </item>
    
    <item>
      <title>安装 Hexo</title>
      <link>https://kouler.com/posts/%E5%AE%89%E8%A3%85hexo/</link>
      <pubDate>Fri, 01 Apr 2016 10:11:57 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E5%AE%89%E8%A3%85hexo/</guid>
      <description> 安装 Node.js 安装 Hexo  1$ sudo npm install -g hexo-cli 初始化 Hexo  1$ hexo init &amp;lt;folder&amp;gt; 2$ cd &amp;lt;folder&amp;gt; 3$ npm install 生成静态页面  1$ hexo generate 在 Github 新建项目 填写网站及Git配置信息 _config.yml  1deploy: 2 type: git 3 repo: https://github.com/koulerz/kouler.git 安装 hexo-deployer-git  1$ npm install hexo-deployer-git --save 部署项目到 Github  1$ hexo deploy </description>
    </item>
    
  </channel>
</rss>