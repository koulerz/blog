<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kouler</title>
    <link>https://kouler.com/</link>
    <description>Recent content on Kouler</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 17 Jan 2020 22:42:14 +0800</lastBuildDate>
    
	<atom:link href="https://kouler.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>使用 Hugo</title>
      <link>https://kouler.com/posts/use-hugo/</link>
      <pubDate>Fri, 17 Jan 2020 22:42:14 +0800</pubDate>
      
      <guid>https://kouler.com/posts/use-hugo/</guid>
      <description>Hugo 安装和配置  Hugo Documentation minimal-bootstrap-hugo-theme  Hugo 常用命令 1$ hugo help // 帮助命令 2$ hugo version // 打印版本号 3$ hugo new site sitename // 创建新站点 4$ hugo new posts/new-post.md // 创建新文章 5$ hugo // 生成静态页面 6$ hugo server // 启动 Hugo Web Server 在 Github 托管 Hugo  Host on GitHub  Github Pages site 配置个人域名  在发布项目根目录添加 CNAME 文件，内容为个人域名 配置个人域名 DNS，添加 CNAME 记录，将 www 子域指向个人 Github Pages site 地址，yourname.</description>
    </item>
    
    <item>
      <title>Debian Ubuntu 更新内核并开启 TCP BBR 功能</title>
      <link>https://kouler.com/posts/debian-ubuntu%E6%9B%B4%E6%96%B0%E5%86%85%E6%A0%B8%E5%B9%B6%E5%BC%80%E5%90%AFtcp-bbr%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Sat, 16 Jun 2018 03:37:24 +0800</pubDate>
      
      <guid>https://kouler.com/posts/debian-ubuntu%E6%9B%B4%E6%96%B0%E5%86%85%E6%A0%B8%E5%B9%B6%E5%BC%80%E5%90%AFtcp-bbr%E5%8A%9F%E8%83%BD/</guid>
      <description>BBR (Bottleneck Bandwidth and RTT) 是 Google 提供的 TCP 拥塞控制算法，适用于复杂网络环境下的 TCP 加速。
 Debian 8.x 或者 Debian 9.x 系统，当然以下教程也适合 Ubuntu 14.04 或 Ubuntu 16.04 如果是虚拟机，那么得使用 KVM 或 Xen 等可以修改内核的平台，OpenVZ 方法我们不做介绍  升级内核 BBR 只支持 4.9.x 以上的内核，所以我们需要更新升级以下
如果你使用的是 Debian 9.x，那么这一步可以直接跳过，其他三个内核版本较旧的系统，我们可以使用 Ubuntu 打包好的内核安装包
首先，找到 4.9.x 以上版本的稳定内核，这里我们推荐使用 LTS 版本，目前最新的是 4.9.40 下载安装即可
1mkdir kernel-tmp &amp;amp;&amp;amp; cd kernel-tmp 2wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.9.88/linux-headers-4.9.88-040988_4.9.88-040988.201803181131_all.deb 3wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.9.88/linux-headers-4.9.88-040988-generic_4.9.88-040988.201803181131_amd64.deb 4wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.9.88/linux-image-4.9.88-040988-generic_4.9.88-040988.201803181131_amd64.deb 5sudo dpkg -i *.deb 安装完以后直接 reboot 重启，一切顺利的话请检查以下当前的内核版本
1root@debian ~ # uname -r 24.</description>
    </item>
    
    <item>
      <title>早期IOS设备强制恢复系统方法</title>
      <link>https://kouler.com/posts/%E6%97%A9%E6%9C%9Fios%E8%AE%BE%E5%A4%87%E5%BC%BA%E5%88%B6%E6%81%A2%E5%A4%8D%E7%B3%BB%E7%BB%9F%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 09 Apr 2018 21:41:39 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E6%97%A9%E6%9C%9Fios%E8%AE%BE%E5%A4%87%E5%BC%BA%E5%88%B6%E6%81%A2%E5%A4%8D%E7%B3%BB%E7%BB%9F%E6%96%B9%E6%B3%95/</guid>
      <description>关机后按住返回键 与电脑连接数据线 打开 iTunes 后自动弹出恢复,期间必须按住返回键  有误的官方做法</description>
    </item>
    
    <item>
      <title>无线路由器之间设置有线中继</title>
      <link>https://kouler.com/posts/%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B9%8B%E9%97%B4%E8%AE%BE%E7%BD%AE%E6%9C%89%E7%BA%BF%E4%B8%AD%E7%BB%A7/</link>
      <pubDate>Fri, 23 Mar 2018 01:39:15 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B9%8B%E9%97%B4%E8%AE%BE%E7%BD%AE%E6%9C%89%E7%BA%BF%E4%B8%AD%E7%BB%A7/</guid>
      <description> 第二个路由器关闭 DHCP 服务 WAN 口自动获取 IP 或者手动配制成第一个路由器的局域网 设置第二个路由器的密码，加密方式，ssid 和第一个一样，信道不能和第一个一样 第一个路由的 LAN 口进第二个路由的 LAN 口  </description>
    </item>
    
    <item>
      <title>版本号规范</title>
      <link>https://kouler.com/posts/%E7%89%88%E6%9C%AC%E5%8F%B7%E8%A7%84%E8%8C%83/</link>
      <pubDate>Sun, 11 Mar 2018 16:03:55 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E7%89%88%E6%9C%AC%E5%8F%B7%E8%A7%84%E8%8C%83/</guid>
      <description>版本号组成和范例 &amp;lt;主版本号&amp;gt;.&amp;lt;次版本号&amp;gt;.&amp;lt;修订号&amp;gt;-&amp;lt;先行版本号&amp;gt;+&amp;lt;版本编译信息&amp;gt;
# 主版本号+次版本号+修订号 范例： 0.1.0 1.0.0 1.0.9 1.10.0 # 主版本号+次版本号+修订号+先行版本号 范例： 1.0.0-alpha 1.0.0-alpha.1 1.0.0-0.3.7 1.0.0-x.7.z.92 # 主版本号+次版本号+修订号+先行版本号+版本编译信息 范例： 1.0.0-alpha+001 1.0.0+20130313144700 1.0.0-beta+exp.sha.5114f85 版本号中希腊字母标识 Alpha 版： 也叫 α 版，此版本主要是以实现软件功能为主，通常只在软件开发者内部交流，一般而言，该版本软件的 Bug 较多，需要继续修改。
Beta 版： 此版本相对于 α 版已经有了很大的改进，消除了严重的错误，但还是存在着一些缺陷，需要经过多次测试来进一步消除，此版本主要的修改对香是软件的 UI。
RC 版： （Release Candidate）发布候选版本，此版本已经相当成熟了，基本上不存在导致错误的 BUG，与即将发行的正式版相差无几，测试人员基本通过的版本。
Release 版： 此版本意味着最终版本、上线版本，在前面版本的一系列测试版之后，终归会有一个正式版本，是最终交付用户使用的一个版本。该版本有时也称为标准版。一般情况下，Release 不会以单词形式出现在软件封面上，取而代之的是符号 (R)。
版本号修改规则 主版本号： 当功能模块有较大的变动，比如增加多个模块或者整体架构发生变化。此版本号由项目决定是否修改。
次版本号： 当功能有一定的增加或变化，比如增加了对权限控制、增加自定义视图等功能。此版本号由项目决定是否修改。
修订号： 一般是 Bug 修复或是一些小的变动，要经常发布修订版，时间间隔不限，修复一个严重的bug即可发布一个修订版。此版本号由项目经理决定是否修改。
先行版本号： 被标上先行版本号则表示这个版本并非稳定而且可能无法达到兼容的需求。
版本编译信息： 可以记录修改项目的当前日期或编译信息，每天对项目的修改都需要更改日期版本号。版本编译信息不标识版本优先级，因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。
参考 &amp;amp; 扩展  语义化版本 2.0.0 APP版本号命名规范及原则  </description>
    </item>
    
    <item>
      <title>终端设置代理</title>
      <link>https://kouler.com/posts/%E7%BB%88%E7%AB%AF%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</link>
      <pubDate>Fri, 09 Mar 2018 10:46:39 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E7%BB%88%E7%AB%AF%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</guid>
      <description>设置和取消临时代理 临时代理在退出当前终端后失效
1# 设置临时 HTTP 代理 2export http_proxy=http://proxyAddress:port 3 4# 设置临时 SOCKS5 代理 5export ALL_PROXY=socks5://proxyAddress:port 6 7# SS 下的 HTTP 代理 8export http_proxy=http://127.0.0.1:1087 9 10# 取消临时代理 11unset http_proxy 12unset ALL_PROXY 参考 &amp;amp; 扩展  让终端走代理的几种方法  </description>
    </item>
    
    <item>
      <title>迁移 Git 仓库</title>
      <link>https://kouler.com/posts/%E8%BF%81%E7%A7%BBgit%E4%BB%93%E5%BA%93/</link>
      <pubDate>Fri, 26 May 2017 13:21:15 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E8%BF%81%E7%A7%BBgit%E4%BB%93%E5%BA%93/</guid>
      <description>1// 切换到需要迁移的 Git 项目目录 2$ cd project 3 4// 添加 Git 远程仓库 5$ git remote add gitlab git@gitlab.com:team/name.git 6 7// 迁移代码到远程仓库 8$ git push -u gitlab master 参考 &amp;amp; 扩展阅读  如何把已存在的git项目转移到Gitlab项目 Git远程操作详解  </description>
    </item>
    
    <item>
      <title>SSH 动态端口转发</title>
      <link>https://kouler.com/posts/ssh%E5%8A%A8%E6%80%81%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</link>
      <pubDate>Fri, 26 May 2017 00:35:46 +0800</pubDate>
      
      <guid>https://kouler.com/posts/ssh%E5%8A%A8%E6%80%81%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</guid>
      <description>当我们在一个不安全的 WiFi 环境下上网，用 SSH 动态转发来保护我们的网页浏览及 MSN 信息无疑是十分必要的。
动态转发的命令格式：
1$ ssh -D &amp;lt;local port&amp;gt; &amp;lt;SSH Server&amp;gt; 这里 SSH 创建了一个 SOCKS 代理服务。我们可以直接使用 localhost:7001 来作为正常的 SOCKS 代理来使用，直接在浏览器或 MSN 上设置即可。在 SSH Client 端无法访问的网站现在也都可以正常浏览。而这里需要值得注意的是，此时 SSH 所包护的范围只包括从浏览器端（SSH Client 端）到 SSH Server 端的连接，并不包含从 SSH Server 端 到目标网站的连接。如果后半截连接的安全不能得到充分的保证的话，这种方式仍不是合适的解决方案。
SSH 隧道的搭建 首先需要有一台支持 SSH 的墙外服务器，此服务器只要能 SSH 连接即可。
客户端 SSH 执行如下命令：
1$ ssh -D 7001 username@remote-host 上述命令中 -D 表示动态绑定，7001 表示本地 SOCKS 代理的侦听端口，可以改成别的，后面的 username@remote-host 就是登录远程服务器的用户名和主机。当然，这个命令后会提示输入密码，就是 username 这个用户的密码（除非配置了SSH公钥认证，可以不输入密码）这样隧道就打通了！
最后在浏览器或者其他应用程序上设置 SOCKS 代理(设置 v4 的 SOCKS 就可以了，v5 的 SOCKS 增加了鉴权功能)，代理指向 127.</description>
    </item>
    
    <item>
      <title>复杂请求的跨域解决方法</title>
      <link>https://kouler.com/posts/%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 17 Feb 2017 19:22:38 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</guid>
      <description>简单请求遇到跨域问题时，只需要在服务器端设置响应头中加入允许跨域的头部信息即可。
当遇到复杂请求时，浏览器为了防止跨域请求无端对服务器数据造成损坏会先发送一个 Options 的预检请求。服务器应该对其进行处理，决定是否允许当前客户端进一步发起跨域请求。随后浏览器会根据 Options 请求的响应信息来决定是否进行下一步真实的请求。
服务器在此次 Options 请求的返回内容中还可以指示浏览器，是否在下次请求携带相关的 Cookie 或者 Http Authentication 数据过来。
什么是简单请求  仅使用 Get 方法的请求。 仅使用 Head 方法的请求。 仅使用 Content-Type 为 application/x-www-form-urlencoded、multipart/form-data 或 text/plain 发起的 Post 请求。  什么是复杂请求 不满足简单请求条件的都属于复杂请求。
解决复杂请求下的跨域问题 1&amp;lt;?php 2 3class CORSMiddleware 4{ 5 public function handle($request, Closure $next) 6 { 7 // 跨域请求时浏览器会先使用 options 方法判断是否允许当前域名发送跨域请求 8 $origin = isset($_SERVER[&amp;#39;HTTP_ORIGIN&amp;#39;]) ? $_SERVER[&amp;#39;HTTP_ORIGIN&amp;#39;] : &amp;#39;&amp;#39;; 9 10 $allow_origin = array( 11 &amp;#39;http://localhost:8888&amp;#39;, 12 &amp;#39;http://test.com&amp;#39;, 13 &amp;#39;https://test.</description>
    </item>
    
    <item>
      <title>Laravel 字段验证</title>
      <link>https://kouler.com/posts/laravel%E5%AD%97%E6%AE%B5%E9%AA%8C%E8%AF%81/</link>
      <pubDate>Sat, 17 Dec 2016 18:06:02 +0800</pubDate>
      
      <guid>https://kouler.com/posts/laravel%E5%AD%97%E6%AE%B5%E9%AA%8C%E8%AF%81/</guid>
      <description>手动创建验证程序示例 1&amp;lt;?php 2 3$data = [ 4 &amp;#39;email&amp;#39; = &amp;#39;aaa@gmail.com&amp;#39;, 5 &amp;#39;name&amp;#39;=&amp;#39;aaa&amp;#39;, 6 &amp;#39;password&amp;#39;=&amp;#39;aaa&amp;#39; 7]; 8 9$rules = array( 10 &amp;#39;email&amp;#39; =&amp;gt; &amp;#39;required|email&amp;#39;, 11 &amp;#39;name&amp;#39; =&amp;gt; &amp;#39;required|between:1,20&amp;#39;, 12 &amp;#39;password&amp;#39; =&amp;gt; &amp;#39;required|min:8&amp;#39;, 13); 14 15$message = array( 16 &amp;#39;required&amp;#39; =&amp;gt; &amp;#39;:attribute 不能为空&amp;#39;, 17 &amp;#39;between&amp;#39; =&amp;gt; &amp;#39;:attribute 长度必须在 :min 和 :max 之间&amp;#34; 18); 1920$attributes = array( 21&amp;#39;email&amp;#39; =&amp;gt; &amp;#39;电子邮件&amp;#39;, 22&amp;#39;name&amp;#39; =&amp;gt; &amp;#39;用户名&amp;#39;, 23&amp;#39;password&amp;#39; =&amp;gt; &amp;#39;用户密码&amp;#39;, 24); 25 26$validate = Validator::make($data,$rules,$message,$attributes); 27 28var_dump($validate-&amp;gt;fails()); 29var_dump($validate-&amp;gt;messages()); 30var_dump($validate-&amp;gt;messages()-&amp;gt;first()) Validator 的验证扩展 1&amp;lt;?</description>
    </item>
    
    <item>
      <title>MacOS 无法获得权限问题</title>
      <link>https://kouler.com/posts/macos%E6%97%A0%E6%B3%95%E8%8E%B7%E5%BE%97%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 20 Nov 2016 22:40:40 +0800</pubDate>
      
      <guid>https://kouler.com/posts/macos%E6%97%A0%E6%B3%95%E8%8E%B7%E5%BE%97%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/</guid>
      <description>通常情况下，在命令行中使用 sudo 命令便可以以 Root 用户执行命令
在 MacOS 中，某些系统文件夹下，即使使用 sudo 命令也无法获得 Root 权限，这被称为 System Integrity Protection（SIP）
要想关闭 SIP，需要进入 Recover 模式下设置，具体方法如下：
 重启电脑，开机时按住 Command + r 键进入 Recover 模式 在工具中找到 Terminal 命令行终端 在命令行中输入命令 csrutil disable 重新启动后 SIP 就被关闭了  如需重新打开 SIP 保护，操作步骤一样，执行命令为 csrutil enable</description>
    </item>
    
    <item>
      <title>Lumen 问题汇总</title>
      <link>https://kouler.com/posts/lumen%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</link>
      <pubDate>Wed, 19 Oct 2016 11:42:41 +0800</pubDate>
      
      <guid>https://kouler.com/posts/lumen%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</guid>
      <description>lumen 安装在子目录下时访问首页出现404错误 public/index.php 中的
1&amp;lt;?php 2 3$app-&amp;gt;run(); 改为
1&amp;lt;?php 2 3$app-&amp;gt;run($app[&amp;#39;request&amp;#39;]); lumen 配置数据库  在根目录添加 .env 配置文件并修改数据库信息 app.php 文件中去掉 Dotenv::load(__DIR__ . &#39;/../&#39;);行的注释，只有去掉才可以使用env配置文件 控制器文件中通过 app 函数来调用数据库，例： $result = app(&#39;db&#39;)-&amp;gt;select(&amp;quot;select * from xay_waiter&amp;quot;);  详细信息
使用 Session  开启Facades，开启方式是去掉 bootstrap/app.php 中 $app-&amp;gt;withFacades(); 的注释。 开启 Session，开启方式：去掉 bootstrap/app.php 中 $app-&amp;gt;middleware(); 的 StartSession 中间件的注释。 使用时发生错误：Class &amp;lsquo;Memcached&amp;rsquo; not found ，因为在 .env 文件中，Session 的默认驱动是：memcached。修改即可。 目前支持的驱动有：file、cookie、database、memcached、redis、array。   Session::put(&#39;key&#39;, &#39;value&#39;); // 保存对象到 Session 中 $value = Session::get(&#39;key&#39;); // 从 Session 取回对象 $value = Session::pull(&#39;key&#39;, &#39;default&#39;); // 从 Session 取回对象并删除 $data = Session::all(); // 从 Session 取出所有对象 Session::has(&#39;users&#39;); // 判断对象在 Session 中是否存在 Session::forget(&#39;key&#39;); // 从 Session 中移除对象 Session::flush(); // 清空所有 Session    lumen 发送邮件  在 composer.</description>
    </item>
    
    <item>
      <title>RESTful 设计风格中的 HTTP 状态码含义</title>
      <link>https://kouler.com/posts/restful%E8%AE%BE%E8%AE%A1%E9%A3%8E%E6%A0%BC%E4%B8%AD%E7%9A%84http%E7%8A%B6%E6%80%81%E7%A0%81%E5%90%AB%E4%B9%89/</link>
      <pubDate>Wed, 19 Oct 2016 11:35:15 +0800</pubDate>
      
      <guid>https://kouler.com/posts/restful%E8%AE%BE%E8%AE%A1%E9%A3%8E%E6%A0%BC%E4%B8%AD%E7%9A%84http%E7%8A%B6%E6%80%81%E7%A0%81%E5%90%AB%E4%B9%89/</guid>
      <description>状态码 类型 含义     100 ~ 消息 代表请求已被接受，需要继续处理   200 ~ 成功 代表请求已成功被服务器接收、理解、并接受   300 ~ 重定向 代表需要客户端采取进一步的操作才能完成请求   400 ~ 请求错误 代表了客户端看起来可能发生了错误，妨碍了服务器的处理   500 ~ 服务器错误 代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理   600 ~ 服务器错误 代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理        状态代码 状态信息 含义 适用情况 对应懒喵项目错误号     100 Continue 初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新）     101 Switching Protocols 服务器将遵从客户的请求转换到另外一种协议（HTTP 1.</description>
    </item>
    
    <item>
      <title>浏览器提示检测到了网络变化解决方法</title>
      <link>https://kouler.com/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%90%E7%A4%BA%E6%A3%80%E6%B5%8B%E5%88%B0%E4%BA%86%E7%BD%91%E7%BB%9C%E5%8F%98%E5%8C%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 19 Oct 2016 11:25:02 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%90%E7%A4%BA%E6%A3%80%E6%B5%8B%E5%88%B0%E4%BA%86%E7%BD%91%E7%BB%9C%E5%8F%98%E5%8C%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</guid>
      <description>问题 会有 ERR_CERT_DATABASE_CHANGED 与 NETWORK CHANGED 的提示。有时候会自动立刻刷新重载。 大部分 HTTPS 内的 AJAX 请求很多都发送失败，导致页面无法正常使用。
解决方法 和 com.alipay.DispatcherService 支付宝插件有关 命令行中使用命令
1$ sudo launchctl remove com.alipay.DispatcherService 停掉支付宝服务就没有这个问题了
参考 &amp;amp; 扩展阅读  MacOS Sierra 升级 CHROME 用 HTTPS 访问间歇性失败  </description>
    </item>
    
    <item>
      <title>浏览器拦截第三方 Cookies 解决方法</title>
      <link>https://kouler.com/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8B%A6%E6%88%AA%E7%AC%AC%E4%B8%89%E6%96%B9cookies%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 13 Oct 2016 12:09:37 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8B%A6%E6%88%AA%E7%AC%AC%E4%B8%89%E6%96%B9cookies%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</guid>
      <description>高版本的 Safari 浏览器为了保护用户隐私会默认阻止第三方的 Cookies。Web 开发中，使用第三方资源非常常见，大多数情况下，这并不会带来问题。然而当我们希望能读写第三方域下的 Cookies 时，就会遇到 Cookies 被拦截的情况从而导致各种问题。
第三方指的是谁 当用户请求某一域名下的页面时，如果页面中引用了另一个域名下的资源，则另一个域名被算作第三方。
解决第三方 Cookies 被拦截的方法 方法一: 客户端手动修改设置。例如 Safari 可以通过偏好设置中的隐私栏修改 Cookies 的安全策略。
方法二: 将需要请求的第三方资源放在本域下。
前两种方法有各自的限制，如果无法解决问题，则需要考虑更复杂的解决方法。
方法三: Safari 会在第三方域下完全没有 Cookies 时阻止第三方 Cookies，而第三方域下只要有过任意一个 Cookie，即可顺利读写。 据此，我们可以考虑当第三方域下没有 Cookies 时，首先将页面先跳到这个域，写入任意 Cookies，再跳回来。或者弹出一个新窗口，写入 Cookies，再关闭弹窗。
方法四: Safari 只阻止了第三方 Cookies，并没有阻止第三方 LocalStorage，于是，我们便可以使用更为激进的方案，即放弃第三方 Cookies，使用 LocalStorage 来代替。
参考 &amp;amp; 扩展阅读  当浏览器默认禁用第三方cookie  </description>
    </item>
    
    <item>
      <title>PHP 中获取 POST 数据的方式</title>
      <link>https://kouler.com/posts/php%E4%B8%AD%E8%8E%B7%E5%8F%96post%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Tue, 13 Sep 2016 18:42:34 +0800</pubDate>
      
      <guid>https://kouler.com/posts/php%E4%B8%AD%E8%8E%B7%E5%8F%96post%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F/</guid>
      <description>form-data x-www-form-urlencoded raw     $_POST 推荐 推荐 无效   $GLOBALS[&amp;lsquo;HTTP_RAW_POST_DATA&amp;rsquo;] 无效 无效 有效   php://input 无效 有效 推荐    $_POST 方式 通过 HTTP POST 方法传递的变量组成的数组。是自动全局变量。
Coentent-Type 仅在取值为 application/x-www-data-urlencoded 或 multipart/form-data 两种情况下，PHP才会将 HTTP 请求数据包中相应的数据填入全局变量 $_POST。
$GLOBALS[&amp;lsquo;HTTP_RAW_POST_DATA&amp;rsquo;] 方式 此变量仅在碰到未识别 MIME 类型的数据时产生。
PHP 默认识别的数据类型是 application/x-www.form-urlencoded 标准的数据类型。如果 POST 过来的数据不是 PHP 能够识别的，比如 text/xml 或者 soap 等可以用 $GLOBALS[&amp;lsquo;HTTP_RAW_POST_DATA&amp;rsquo;]方式来接收。
不过，访问原始 POST 数据的更好方法是 php://input。
php://input 方式 php://input 允许读取 POST 的原始数据。和 $HTTP_RAW_POST_DATA 比起来，它给内存带来的压力较小，并且不需要任何特殊的 php.</description>
    </item>
    
    <item>
      <title>PhpStorm 常用快捷键</title>
      <link>https://kouler.com/posts/phpstorm%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</link>
      <pubDate>Tue, 21 Jun 2016 00:38:50 +0800</pubDate>
      
      <guid>https://kouler.com/posts/phpstorm%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid>
      <description>文本编辑    快捷键 描述     Command + Alt + I 对当前文件进行格式化排版   Control + G 顺序选中相同的文本   Shift + Enter 在当前行下方插入新行   Command + Alt + Enter 在当前行上方插入新行   Command + / 单行注释   Command + Shift + / 块代码注释   Command + D 复制当前行   Command + P 查看当前函数参数   Command + Shift + Enter 补全代码（if）   Alt + / 自动完成   Alt + Click 插入多个光标（鼠标单击）   Alt Alt + Up 向上插入多个光标（双击 Alt 并按住）   Alt Alt + Down 向下插入多个光标（双击 Alt 并按住）   Alt + Double Click 选中多个文本（鼠标双击）   Alt + Mouse 选中多个文本（鼠标拖动）   Ctrl + Mouse 复制选中文本（鼠标拖动）   Command + Mouse 移动选中文本（鼠标拖动）   Command + J 活动代码提示   Command + Alt + T 插入环绕代码   Command + .</description>
    </item>
    
    <item>
      <title>WebServer 和 CGI 以及 PHPFPM 之间的关系</title>
      <link>https://kouler.com/posts/webserver%E5%92%8Ccgi%E4%BB%A5%E5%8F%8Aphpfpm%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Wed, 15 Jun 2016 23:28:36 +0800</pubDate>
      
      <guid>https://kouler.com/posts/webserver%E5%92%8Ccgi%E4%BB%A5%E5%8F%8Aphpfpm%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</guid>
      <description>WebServer 最早的 Web服务器简单地响应浏览器发来的 HTTP 请求，并将存储在服务器上的 HTML 文件返回给浏览器，也就是静态HTML。
但事物总是不断发展的，网站也逐渐变得复杂，所以出现动态技术。但是 Web服务器并不能直接运行 php，asp 这样的文件，当浏览器请求 index.php?a=1&amp;amp;b=2 时，Web服务器就不知道该如何处理了，它不能理解 “php”、“?”、“&amp;amp;”、“a”、“b” 各是什么意思，这时它就需要调用相应的脚本解释程序（如PHP-CGI）来处理这样的请求。
CGI Web服务器不知道如何处理动态页面请求，需要移交其他程序来处理，这时需要与该程序做个约定，我给你什么，然后你给我什么，就是我把请求参数（如 a=1，b=2）发送给你，然后我接收你的处理结果给客户端。那这个约定就是 Common Gateway Interface，简称 CGI。这个协议可以用 VB，C，PHP，Python 等语言来实现。
CGI 只是接口协议，根本不是什么语言。
WebServer 与 CGI 程序的交互 Web服务器将根据 CGI程序的类型决定数据向 CGI程序的传送方式，通常是通过标准输入/输出流和环境变量来传递。
CGI程序通过标准输入（STDIN）和标准输出（STDOUT）来进行输入输出。此外 CGI程序还通过环境变量来得到输入。
操作系统提供了许多环境变量，它们定义了程序的执行环境，应用程序可以存取它们。
Web服务器和 CGI接口又另外设置了一些环境变量，用来向 CGI程序传递一些重要的参数。
下面是一些常用的 CGI 环境变量：
   变量名 描述     CONTENT_TYPE 这个环境变量的值指示所传递来的信息的MIME类型   CONTENT_LENGTH 如果服务器与 CGI 程序信息的传递方式是 POST，这个环境变量即是从标准输入 STDIN中可以读到的有效数据的字节数。这个环境变量在读取所输入的数据时必须使用   HTTP_COOKIE 客户机内的 COOKIE 内容   HTTP_USER_AGENT 提供包含了版本数或其他专有数据的客户浏览器信息   PATH_INFO 这个环境变量的值表示紧接在 CGI 程序名之后的其他路径信息。它常常作为 CGI 程序的参数出现   QUERY_STRING 如果服务器与 CGI 程序信息的传递方式是 GET，这个环境变量的值即使所传递的信息。这个信息经跟在CGI程序名的后面，两者中间用一个问号分隔   REMOTE_ADDR 这个环境变量的值是发送请求的客户机的 IP 地址，它是 WEB客户机需要提供给 WEB服务器的唯一标识，可以在 CGI 程序中用它来区分不同的 Web客户机   REMOTE_HOST 这个环境变量的值包含发送 CGI 请求的客户机的主机名。如果不支持你想查询，则无需定义此环境变量   REQUEST_METHOD 提供脚本被调用的方法。对于使用 HTTP/1.</description>
    </item>
    
    <item>
      <title>Linux0.11 内核引导启动流程</title>
      <link>https://kouler.com/posts/linux011%E5%86%85%E6%A0%B8%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Fri, 10 Jun 2016 22:36:02 +0800</pubDate>
      
      <guid>https://kouler.com/posts/linux011%E5%86%85%E6%A0%B8%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid>
      <description>计算机加电后，最开始 BIOS 中的程序会先开始执行，BIOS 程序执行结束后，将由操作系统接管。
引导启动过程中会用到的内核文件说明 boot / bootsect.s : 该程序是磁盘引导块程序，编译后会驻留在磁盘的第一个扇区中（即引导扇区中，0 磁道（柱面），0 磁头，第一个扇区）。计算机机加电 ROM BIOS 自检后，将被 BIOS 加载到内存 0x7C00 处执行。
boot / setup.s : 该程序主要用于读取机器的硬件配置参数，并把内核模块 system 移动到适当的内存位置处。
boot / head.s : 该程序会被编译连接在 system 模块的最前部分，主要进行硬件设备的探测设置和内存管理页面的初始化设置工作。
引导启动过程中文件运行顺序图 BIOS 程序执行流程  计算机加电，80x86 结构的 CPU 自动进入实模式，并从地址 0xFFFF0 开始自动执行代码。这个地址也就是 ROM-BIOS 中的地址。 BIOS 执行系统检测，并在物理地址 0 处初始化中断向量。 BIOS 将可启动设备的第一个扇区（磁盘引导扇区，512字节）读入内存绝对地址 0x7C00 处并跳转到这个地方。  接下来将由操作系统文件接管启动流程。
操作系统程序执行流程 Linux 的最最前面部分是用 8086 汇编语言编写的（bootsect.s）。它由 BIOS 读入到内存绝对地址 0x7C00（31KB）处。
 bootsect.s 执行时会把自己移动到内存绝对地址 0x90000（576KB）处。 bootsect.s 将启动设备中后 2KB 字节代码（setup.</description>
    </item>
    
    <item>
      <title>Bash 命令行快捷键</title>
      <link>https://kouler.com/posts/bash%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/</link>
      <pubDate>Mon, 23 May 2016 22:45:49 +0800</pubDate>
      
      <guid>https://kouler.com/posts/bash%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid>
      <description>编辑命令 Ctrl + a ：移到命令行首 Ctrl + e ：移到命令行尾 Ctrl + f ：按字符前移（右向） Ctrl + b ：按字符后移（左向） Ctrl + xx：在命令行首和光标之间移动 Ctrl + u ：从光标处删除至命令行首 Ctrl + k ：从光标处删除至命令行尾 Ctrl + d ：删除光标后的字符 Ctrl + h ：删除光标前的字符 Bang (!) 命令 !!： 执行上一条命令 !blah： 执行最近的以 blah 开头的命令，如 !ls !blah:p：仅打印输出，而不执行 !$： 上一条命令的最后一个参数，与 Alt + . 相同 !$:p： 打印输出 !$ 的内容 !*： 上一条命令的所有参数 !*:p： 打印输出 !* 的内容 ^blah： 删除上一条命令中的 blah ^blah^foo： 将上一条命令中的 blah 替换为 foo ^blah^foo^： 将上一条命令中所有的 blah 都替换为 foo 参考 &amp;amp; 扩展阅读  让你提升命令行效率的 Bash 快捷键  </description>
    </item>
    
    <item>
      <title>跨域问题解决方法</title>
      <link>https://kouler.com/posts/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 23 May 2016 17:35:00 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</guid>
      <description>本文通过设置 Access-Control-Allow-Origin 来实现跨域。 例如：客户端的域名是 client.com，而请求的域名是 server.com。 如果直接使用 ajax 访问，会有以下错误：
XMLHttpRequest cannot load http://server.com/server.php. No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;http://client.com&#39; is therefore not allowed access. 允许单个域名访问 指定某域名（ http://client.com ）跨域访问，则只需在 http://server.com/server.php 文件头部添加如下代码：
1&amp;lt;?php 2 3header(&amp;#39;Access-Control-Allow-Origin: http://client.com&amp;#39;); 允许多个域名访问 指定多个域名（ http://client1.com, http://client2.com 等 ）跨域访问，则只需在 http://server.com/server.php 文件头部添加如下代码：
1&amp;lt;?php 2 3$origin = isset($_SERVER[&amp;#39;HTTP_ORIGIN&amp;#39;])? $_SERVER[&amp;#39;HTTP_ORIGIN&amp;#39;] : &amp;#39;&amp;#39;; 4 5$allow_origin = array( 6 &amp;#39;http://client1.com&amp;#39;, 7 &amp;#39;http://client2.com&amp;#39; 8); 9 10if(in_array($origin, $allow_origin)){ 11 header(&amp;#39;Access-Control-Allow-Origin: &amp;#39;.$origin); 12} 允许所有域名访问 允许所有域名访问则只需在 http://server.</description>
    </item>
    
    <item>
      <title>PHP 中的二进制安全</title>
      <link>https://kouler.com/posts/php%E4%B8%AD%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/</link>
      <pubDate>Sat, 14 May 2016 21:47:46 +0800</pubDate>
      
      <guid>https://kouler.com/posts/php%E4%B8%AD%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/</guid>
      <description>二进制安全是什么 先看一段代码：
1&amp;lt;?php 2 3$string1 = &amp;#34;Hello&amp;#34;; 4$string2 = &amp;#34;Hello\0Hello&amp;#34;; 5 6// 返回0, 由于是非二进制安全，误判为相等 7echo strcoll($string1, $string2); 8 9// 返回&amp;lt;0,不相等 10echo strcmp($string1, $string2); 这是为什么呢？PHP 是基于 C 实现的，PHP 代码都会被 Zend引擎编译成 opcode，最终作为 C语言去执行。而对于 C语言中 &amp;ldquo;\0&amp;rdquo; 是字符串的结束符，它读到 &amp;ldquo;\0&amp;rdquo; 就会默认字符读取已经结束，从而抛掉后面的字符串。
1main(){ 2 char ab[] = &amp;#34;Hello&amp;#34;; 3 char ac[] = &amp;#34;Hello\0Hello&amp;#34;; 4 5 // 返回0, 由于是非二进制安全，误判为相等 6 strcmp(ab, ac); 7} 有一个二进制安全的定义:
 程序不会对其中的数据做任何限制、过滤、或者假设 —— 数据在写入时是什么样的，它被读取时就是什么样。
 PHP是如何实现二进制安全的 既然 PHP 是基于 C 实现的，C 字符串类型不是二进制安全的，PHP 又是如何实现的呢？这就是数据结构的功劳了。 PHP 的内核中，是如此定义字符串类型的</description>
    </item>
    
    <item>
      <title>PHP 中的异常捕获</title>
      <link>https://kouler.com/posts/php%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/</link>
      <pubDate>Thu, 12 May 2016 19:17:55 +0800</pubDate>
      
      <guid>https://kouler.com/posts/php%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/</guid>
      <description>PHP 中 try catch 可以帮助我们捕获程序代码的异常以便使我们很好的处理一些不必要的错误。
Try 语句 try 是用来定义检测异常的代码块。 需要进行异常处理的代码都必须放入 try 代码块内，以便捕获可能存在的异常。 每一个 try 至少要有一个与之对应的 catch 。
1&amp;lt;?php 2 3try { 4 // 需要进行异常处理的代码 5} try 代码块有可能运行到最后一行，也有可能抛出异常，如果抛出了异常，代码的剩余部分就会被跳过，程序会跳到 Catch 语句块中执行。
Catch 语句 定义处理发生异常时执行的代码块。使用多个 catch 可以捕获不同的类所产生的异常。
当 try 代码块不再抛出异常或者找不到 catch 能匹配所抛出的异常时，PHP 代码就会在跳转到最后一个 catch 的后面继续执行。 PHP允许在 catch 代码块内再次抛出（throw）异常。
当一个异常被抛出时，其后（指抛出异常时所在的代码块）的代码将不会继续执行，而 PHP 就会尝试查找第一个能与之匹配的 catch。
如果一个异常没有被捕获，而且又没用使用 set_exception_handler() 作相应的处理的话，那么 PHP 将会产生一个严重的错误，并且输出 Uncaught Exception ... （未捕获异常）的提示信息。
1&amp;lt;?php 2 3catch(Exception $e) { 4 echo $e; 5} 上面代码中，$e 是 Exception 类的一个实例。</description>
    </item>
    
    <item>
      <title>Linux 的中断异常和信号</title>
      <link>https://kouler.com/posts/linux%E7%9A%84%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E5%92%8C%E4%BF%A1%E5%8F%B7/</link>
      <pubDate>Tue, 19 Apr 2016 21:42:10 +0800</pubDate>
      
      <guid>https://kouler.com/posts/linux%E7%9A%84%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E5%92%8C%E4%BF%A1%E5%8F%B7/</guid>
      <description>中断 中断是指CPU对系统发生的某个事件作出的一种反应，让CPU暂时停止当前程序的执行转而执行处理新情况的程序和执行过程。即在程序运行过程中，系统出现了一个必须由CPU立即处理的情况，此时，CPU暂时中止程序的执行转而处理这个新的情况的过程就叫做中断。
中断向量: 每个中断和异常是由0~255之间的一个数来标识。Intel把这个8位的无符号整数叫做一个向量。
IRQ: 每个能够发出中断请求的硬件设备控制器都有一条名为IRQ的输出线。所有现有的IRQ线都与一个名为可编程中断控制器的硬件电路的输入引脚相连。
PIC: 可编程中断控制器
IDT: 中断描述符表，中断描述符表是一个系统表，它与每一个中断或异常向量相联系，每一个向量在表中有相应的中断和异常处理程序的入口地址。表中的每一项对应一个中断或异常向量，每个向量由8个字节组成。因此，最多需要256*8=2048字节来存放IDT。
广义的中断包含异步中断和同步中断。
异步中断 异步中断(外部中断/硬件中断)通常被直接称为中断(interrupt)
CPU对其的响应完全是被动的，但是可以屏蔽掉。
异步中断可分为可屏蔽中断（Maskable interrupt）和非屏蔽中断（Nomaskable interrupt）。
所谓的异步指的是发生的中断不是随正在执行的指令同步发生的，是由其他硬件设备依照 CPU 时钟信号随机产生的，是不可预知的，例如用户随时在键盘上按下一个键。
同步中断 同步中断(内部中断/软件中断)通常被称为异常(exception)
在Intel的手册中，同步中断被称之为异常。
异常可分为故障(fault)、陷阱(trap)、**终止(abort)**三类。
   类型 原因 异步/同步 返回行为 例子     陷阱 有意的异常 同步 总是返回到下一条指令 系统调用、信号机制 ( 通过软中断实现 )   故障 潜在可恢复的错误 同步 返回到当前指令 缺页异常、除 0 错误、段错误   终止 不可恢复的错误 同步 不会返回 硬件错误    软中断和硬中断 软中断是通信进程之间用来模拟硬中断的一种信号通信方式。是属于一种编程手段，也有称之为软中断通信机制。
硬中断一般就是指的硬件中断，也就是常说的中断，由硬件触发。
区别    类型 产生的位置 发生的时刻 时序     中断 CPU外部 随机 异步   异常 CPU内部 一条指令终止后 同步    信号机制 信号是异步的进程间的通讯机制，是在软件层次上对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。</description>
    </item>
    
    <item>
      <title>PhpStorm 下配置调试环境</title>
      <link>https://kouler.com/posts/phpstorm%E4%B8%8B%E9%85%8D%E7%BD%AE%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Wed, 06 Apr 2016 14:42:30 +0800</pubDate>
      
      <guid>https://kouler.com/posts/phpstorm%E4%B8%8B%E9%85%8D%E7%BD%AE%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/</guid>
      <description>使用 brew 安装 php 和 xdebug
PHP xdebug 配置信息
1[xdebug] 2; xdebug.remote_autostart=1 3zend_extension=&amp;#34;/usr/local/Cellar/php71-xdebug/2.5.5/xdebug.so&amp;#34; 4xdebug.remote_enable=1 5xdebug.remote_handler=&amp;#34;dbgp&amp;#34; 6xdebug.remote_host=localhost 7xdebug.remote_port=9001 8xdebug.idekey=&amp;#34;PHPSTORM&amp;#34; 9xdebug.profiler_enable_trigger=1 10xdebug.profiler_output_dir=&amp;#34;/Users/kouler/Codes/php/xdebug_profiler&amp;#34; 需要注意 xdebug 和 phpfpm 的默认端口都是 9000，端口冲突
参考 &amp;amp; 扩展  在Mac上的PHPSTORM配置XDebug来调试PHP程序 PHP:使用xdebug profiler 做性能分析  </description>
    </item>
    
    <item>
      <title>PostgreSQL JSON 数据类型参考</title>
      <link>https://kouler.com/posts/postgresql-json%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%82%E8%80%83/</link>
      <pubDate>Sun, 03 Apr 2016 12:46:56 +0800</pubDate>
      
      <guid>https://kouler.com/posts/postgresql-json%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%82%E8%80%83/</guid>
      <description> JSON 类型 JSON Functions and Operators PostgreSQL 9.4 中使用 jsonb  </description>
    </item>
    
    <item>
      <title>PostgreSQL 常用操作</title>
      <link>https://kouler.com/posts/postgresql%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sun, 03 Apr 2016 12:21:24 +0800</pubDate>
      
      <guid>https://kouler.com/posts/postgresql%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</guid>
      <description>常用控制台命令 \password 设置密码。 \q 退出。 \h 查看SQL命令的解释，比如\h select。 \? 查看psql命令列表。 \l 列出所有数据库。 \c [database_name] 连接其他数据库。 \d 列出当前数据库的所有表格。 \d [table_name] 列出某一张表格的结构。 \du 列出所有用户。 \e 打开文本编辑器。 \conninfo 列出当前数据库和连接的信息。 常用SQL语句 1# 创建新表 2CREATE TABLE user_tbl(name VARCHAR(20), signup_date DATE); 3 4# 插入数据 5INSERT INTO user_tbl(name, signup_date) VALUES(&amp;#39;张三&amp;#39;, &amp;#39;2013-12-22&amp;#39;); 6 7# 查询记录 8SELECT * FROM user_tbl; 9 10# 更新数据 11UPDATE user_tbl set name = &amp;#39;李四&amp;#39; WHERE name = &amp;#39;张三&amp;#39;; 12 13# 删除记录 14DELETE FROM user_tbl WHERE name = &amp;#39;李四&amp;#39; ; 15 16# 添加字段 17ALTER TABLE user_tbl ADD email VARCHAR(40); 18ALTER TABLE user_tbl ADD COLUMN images jsonb DEFAULT &amp;#39;{}&amp;#39;; 19 20# 更改字段类型 21ALTER TABLE user_tbl ALTER COLUMN signup_date SET NOT NULL; 22 23# 更改字段类型长度 24ALTER TABLE user_tbl ALTER COLUMN password TYPE varchar(32); 25 26# 为字段添加索引 27CREATE INDEX index_name ON user_tbl (name); 28 29# 设置字段默认值（注意字符串使用单引号） 30ALTER TABLE user_tbl ALTER COLUMN email SET DEFAULT &amp;#39;example@example.</description>
    </item>
    
    <item>
      <title>PostgreSQL 中 Json 和 Jsonb 的区别</title>
      <link>https://kouler.com/posts/postgresql%E4%B8%ADjson%E5%92%8Cjsonb%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 02 Apr 2016 15:47:06 +0800</pubDate>
      
      <guid>https://kouler.com/posts/postgresql%E4%B8%ADjson%E5%92%8Cjsonb%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>Postgres 中的 Json 和 Jsonb 数据类型都是用于储存 JSON ( JavaScript Object Notation ) 格式数据。虽然 Text 数据类型也可以用来储存 JSON 数据， 但 JSON 数据类型的优势在于它会根据 JSON 规则来强制要求每个被储存的值都是合法的 JSON 数据。
一般情况下， 除非有特别的要求（比如针对对象键排列顺序的遗留假设，legacy assumption）， 否则的话， 大多数应用程序都应该优先使用 jsonb 类型来储存 JSON 数据。
Json 数据类型 json 数据类型储存输入文本的精确拷贝，处理函数在每次执行的时候，都必须对这些文本重新进行分析。
json 数据类型会保留文本中与 Json 语义完全无关的空白字符，各个键在 Json 对象内的排列顺序以及具有相同键的值。
Jsonb 数据类型 Jsonb 数据类型以无压缩（decomposed）二进制格式来储存数据，因为格式转换带来的花销，这种类型在处理输入的时候速度会稍微慢一些，但是因为这种类型的数据并不需要重新进行分析，所以这种数据的处理速度会明显地快很多。
jsonb 支持索引特性，这是一个明显的优点。
jsonb 不会保留任何无关的空白，不会保留对象键的排列顺序，也不会保留任何重复的对象键。如果输入里面指定了重复的键，那么只有最后一个值会被保留。
jsonb 类型可以检测一个 jsonb 值是否包含了另一个 jsonb 值，而 json 类型并不具备这样的特性。
jsonb 会拒绝那些超出 PostgreSQL 数字类型范围的数字，而 json 则不会这样做。</description>
    </item>
    
    <item>
      <title>安装 Hexo</title>
      <link>https://kouler.com/posts/%E5%AE%89%E8%A3%85hexo/</link>
      <pubDate>Fri, 01 Apr 2016 10:11:57 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E5%AE%89%E8%A3%85hexo/</guid>
      <description> 安装 Node.js 安装 Hexo  1$ sudo npm install -g hexo-cli 初始化 Hexo  1$ hexo init &amp;lt;folder&amp;gt; 2$ cd &amp;lt;folder&amp;gt; 3$ npm install 生成静态页面  1$ hexo generate 在 Github 新建项目 填写网站及Git配置信息 _config.yml  1deploy: 2 type: git 3 repo: https://github.com/koulerz/kouler.git 安装 hexo-deployer-git  1$ npm install hexo-deployer-git --save 部署项目到 Github  1$ hexo deploy </description>
    </item>
    
  </channel>
</rss>