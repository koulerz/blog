<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on Kouler</title>
    <link>https://kouler.com/tags/golang/</link>
    <description>Recent content in golang on Kouler</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 28 Aug 2021 16:15:01 +0800</lastBuildDate>
    
	<atom:link href="https://kouler.com/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>捕获docker stop信号</title>
      <link>https://kouler.com/posts/%E6%8D%95%E8%8E%B7docker-stop%E4%BF%A1%E5%8F%B7/</link>
      <pubDate>Sat, 28 Aug 2021 16:15:01 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E6%8D%95%E8%8E%B7docker-stop%E4%BF%A1%E5%8F%B7/</guid>
      <description>为了优化代码部署效率，将传统的手动部署方式改成了容器化部署方式
过去的程序停止逻辑  程序持续监听 SIGINT 信号 使用 Ctrl + C 快捷键向程序发送 SIGINT 信号 程序收到 SIGINT 信号后执行退出前的收尾工作 收尾工作执行完成后，程序自动退出  容器化后产生的问题 使用容器化部署方式后，期望通过 docker stop 命令来执行程序退出逻辑并关闭程序和容器，结果发现程序和容器被强制关闭，而程序退出前的收尾工作并未执行。
问题产生的原因 上网搜索后得知 docker stop 命令发送的并非 SIGINT 信号，而是 SIGTERM 信号。
而程序代码中并未捕获 SIGTERM 信号，所以收到 SIGTERM 信号后，程序跳过了收尾工作，直接退出了。
修复代码后的程序停止逻辑  程序持续监听 SIGINT 和 SIGTERM 信号 使用 docker stop 命令向程序发送 SIGTERM 信号 收到 SIGTERM 信号后执行退出前的收尾工作 收尾工作执行完成后，程序自动退出  修复代码后，使用 docker stop 命令能够按照预期正确退出程序。</description>
    </item>
    
    <item>
      <title>解决 VSCode 无法安装 Golang 扩展问题</title>
      <link>https://kouler.com/posts/%E8%A7%A3%E5%86%B3vscode%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85golang%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 13 May 2019 19:18:42 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E8%A7%A3%E5%86%B3vscode%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85golang%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98/</guid>
      <description>SS 方法 1 从 SS 复制 HTTP Proxy Shell Export Line
2 设置 Shell 代理
1export http_proxy=http://127.0.0.1:1087; 2export https_proxy=http://127.0.0.1:1087; 3 使用 go get 方式安装
Goproxy 环境变量方法 go 1.11 版本开始新增了 goproxy 环境变量，用于下载源码时设置代理地址
1export GOPROXY=https://goproxy.io 该方法依赖 go module 功能
Go module replace 方法 在 go.mod 文件中将无法安装的包路径替换为其他能够访问的包路径，比如 github 下的包路径
1module hello 2 3require ( 4 golang.org/x/text v0.3.0 5) 6 7# 将限制访问的 golang.org 下的地址替换为能够访问的 github 地址 8replace ( 9 golang.org/x/text =&amp;gt; github.com/golang/text v0.3.0 10) 由于包依赖通常比较多和杂，所以不推荐使用该方法</description>
    </item>
    
    <item>
      <title>Golang WASM Demo</title>
      <link>https://kouler.com/posts/golang-wasm-demo/</link>
      <pubDate>Sun, 26 Aug 2018 16:14:42 +0800</pubDate>
      
      <guid>https://kouler.com/posts/golang-wasm-demo/</guid>
      <description>Golang 1.11 加入了对 WebAssembly 的支持，以下会测试并运行一个简单的 Demo。
 MacOS 10.13.6 Golang 1.11 Chrome 68 (64-bit)   编写测试代码并编译为 WASM 二进制代码 编写 WebServer 代码用于正确加载本地 WASM 文件 使用 Golang 编写好的 HTML 和 JavaScript 加载 WASM 使用浏览器测试代码  编译测试代码 1// 测试代码 main.go 2package main 3 4import &amp;#34;fmt&amp;#34; 5 6func main() { 7 fmt.Println(&amp;#34;hello, Go/WASM!&amp;#34;) 8} 1# 编译命令 修改编译好的文件名称为 test.wasm 以便被自带的 HTML 文件正确加载 2$ GOOS=js GOARCH=wasm go build -o test.wasm main.go 编写 WebServer 代码 1// server.</description>
    </item>
    
    <item>
      <title>Golang 交叉编译</title>
      <link>https://kouler.com/posts/golang%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</link>
      <pubDate>Mon, 05 Mar 2018 18:28:42 +0800</pubDate>
      
      <guid>https://kouler.com/posts/golang%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</guid>
      <description>什么是跨平台交叉编译 交叉编译 通俗地讲就是在一种平台上编译出能运行在体系结构不同的另一种平台上的程序，比如在 PC 平台（X86 CPU）上编译出能运行在以 ARM 为内核的 CPU 平台上的程序，编译得到的程序在 X86 CPU 平台上是不能运行的，必须放到ARM CPU 平台上才能运行，虽然两个平台用的都是 Linux 系统。
交叉编译这种方法在异平台移植和嵌入式开发时非常有用。
本地编译 相对与交叉编译，平常做的编译叫本地编译，也就是在当前平台编译，编译得到的程序也是在本地执行。
用来编译跨平台程序的编译器就叫交叉编译器，相对来说，用来做本地编译的工具就叫本地编译器。
所以要生成在目标机上运行的程序，必须要用交叉编译工具链来完成。在裁减和定制 Linux 内核用于嵌入式系统之前，由于一般嵌入式开发系统存储大小有限，通常都要在性能优越的 PC 上建立一个用于目标机的交叉编译工具链，用该交叉编译工具链在 PC 上编译目标机上要运行的程序。
交叉编译工具链是一个由编译器、连接器和解释器组成的综合开发环境，交叉编译工具链主要由 binutils、gcc 和 glibc 3个部分组成。
有时出于减小 libc 库大小的考虑，也可以用别的 c 库来代替 glibc，例如 uClibc、dietlibc 和 newlib。
Golang 的跨平台交叉编译 Go 语言是编译型语言，可以将程序编译后在将其拿到其它操作系统中运行，此过程只需要在编译时增加对其它系统的支持。
交叉编译依赖下面几个环境变量  $GOARCH 目标平台（编译后的目标平台）的处理器架构（386、amd64、arm） $GOOS 目标平台（编译后的目标平台）的操作系统（darwin、freebsd、linux、windows）  各平台的 GOOS 和 GOARCH 参考    OS ARCH OS version     linux 386 / amd64 / arm &amp;gt;= Linux 2.</description>
    </item>
    
  </channel>
</rss>