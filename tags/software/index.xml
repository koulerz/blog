<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>software on Kouler</title>
    <link>https://kouler.com/tags/software/</link>
    <description>Recent content in software on Kouler</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 26 Sep 2018 12:47:42 +0800</lastBuildDate><atom:link href="https://kouler.com/tags/software/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>面向接口编程</title>
      <link>https://kouler.com/posts/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Wed, 26 Sep 2018 12:47:42 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/</guid>
      <description>面向接口编程和面向对象编程的关系 面向接口编程和面向对象编程并不是平级的，面向接口编程并不是比面向对象编程更先进的一种独立的编程思想，而是附属于面向对象思想体系，属于其中的一部分。或者说，它是面向对象编程体系中的思想精髓之一。
面向接口编程综述 面向接口编程是在系统分析和架构设计中，分清层次和依赖关系，每个层级不直接向其上层提供服务（即不是直接实例化在上层中），而是通过定义一组接口，仅向上层暴露其接口功能，上层对于下层仅仅是接口依赖，而不依赖具体类。
这样做的好处是显而易见的，首先对系统灵活性大有好处。当下层需要改变时，只要接口及接口功能不变，则上层不用做任何修改。甚至可以在不改动上层代码时将下层整个替换掉。比如我们将一个 WD 的 60G 硬盘换成一个希捷的 160G 的硬盘，计算机其他地方不用做任何改动，只需要将原硬盘拔下来，新硬盘插上就行了，因为计算机其他部分不依赖具体硬盘，而只依赖一个 IDE 接口，只要硬盘实现了这个接口，就可以替换上去。从这里看，程序中的接口和现实中的接口极为相似。
使用接口的另一个好处就是不同部件或层次的开发人员可以并行开工，就像造硬盘的不用等造 CPU 的，也不用等造显示器的，只要接口一致，设计合理，完全可以并行进行开发，从而提高效率。
关于抽象类和接口 如果从具体代码来看，对这两个概念很容易模糊。而单从具体功能来看，甚至觉得接口就是多余的，因为除多重继承外，抽象类似乎能完全取代接口。
但接口的存在当然不只是为了实现多重继承。抽象类和接口的区别在于使用动机。使用抽象类是为了代码的复用，而使用接口的动机是为了实现多态性。
Person 这个接口该不该定义，关键看具体应用中的使用情况。如果程序中有 Women 和 Man，都继承 Person，而且 Women 和 Man 绝大多数方法都相同，只有一个方法 ToWC() 不同，那么定义一个 AbstractPerson 抽象类比较合理，因为它可以把其他所有方法都包含进去，子类只定义 ToWC()，大大减少了重复代码量。
但是，如果程序中的 Women 和 Man 两个类基本没有共同代码，而且有一个 PersonHandle 类需要实例化他们，并且不希望知道他们是男是女，而只需把他们当作人看待，并实现多态，那么定义成接口就有必要了。
总而言之，接口与抽象类的区别主要在于使用的动机，而不在于其本身。而一个东西该定义成抽象类还是接口，要根据具体环境的上下文决定。
面向接口编程的代码优化示例 我们要实现老师教儿童背古诗的功能，代码如下：
1// 老师 2class Teacher { 3 public void teach(Children children){} // 教儿童背古诗 4} 5 6// 儿童 7class Children { 8 public void listen(){} // 听课 9 public void recite(){} // 背诵 10} 11 12/* 这是标准的面向对象编程，描述了对象间的关联 */ 随着老师能力的提升，准备扩展服务对象，增加在校学生，代码如下：</description>
    </item>
    
    <item>
      <title>软件架构设计</title>
      <link>https://kouler.com/posts/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Wed, 26 Sep 2018 11:00:42 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</guid>
      <description>子系统的设计 在软件设计的过程中，往往需要对系统的结构层次进行分析，从中抽取出系统的设计框架，通过框架来指导整个软件设计的流程。而一个良好的系统框架也是决定整个系统的稳定性、封闭性、可维护性的重要条件之一。
复杂的系统，最好先按业务领域横向拆分成可独立部署的子系统，每个子系统内部再按技术和业务纵向拆分成不同的模块。
举例来说，按照一般的模块化或者功能拆分方法，我们可以将一个完善的电商系统分解为商品、库管、订单、支付、财务、结算、配送、搜索、CRM、虚拟货币、优惠票券、短信、邮件、活动等子系统。而子系统可以再次按照模块或者功能细分，比如订单系统可以按商品品类或者活动类型或者线上线下等维度拆分。支付系统可以按照内外部支付方式、支付和风控策略、支付模式（如跳转或直连等）等不同维度进行划分。
子系统设计准则 分而治之，划分模块 子系统还可以拆分子系统，服务还可以拆分子服务，这里涉及到一个粒度的问题，非常考验设计者的水平和经验，需要准确把握，否则很容易过度设计
分层
如果真正理解分层的含义，在很多情况下，多层不如经典三层
保证隔离，划清界限 不要过多假设，不要拖泥带水，任何模块或服务只做它该做的事情。实现隔离的最佳方法，就是面向接口编程，而不是针对具体实现编程 Programming to an Interface, not an Implementation
多态
如果一定要复用类，请优先使用对象的组合而非继承
提取变化剧烈的点，定期重构，核心业务逻辑必须单元测试
UI 变化最大，其次是业务逻辑，很多时候 UI 变化会直接影响后端业务逻辑，所以，接口设计要向 UI 和业务逻辑倾斜，基础框架和服务相对稳定，无需过度设计
模块的设计 系统模块划分过程中，要充分遵照当前系统的框架结构。模块的划分要和系统的结构层次相结合，根据系统层次对各个模块也进行层次划分。如果系统的模块划分和框架结构相违背的话，则会导致数据混乱，接口复杂，模块耦合性过高等问题出现。
进行模块划分时，很多情况下不能清晰的把握每个模块的具体内容。往往会从需求归类或数据统一的角度上来设计模块。这种设计理念是对的，但如果只是单纯从这几个方面进行模块设计，会导致在模块划分上出现一些问题。
比如设计的某一个模块，虽然数据接口统一，但内部实现的功能非常多，单一模块的规模过大，包含的内容过多，会导致程序实现难度增加，数据处理流程变得复杂，程序维护性降低，出错范围不易确定等问题出现。同时，由于模块实现的功能丰富，则必然会导致接口也变得繁多，那么与其他模块之间的独立性就得不到保证，严重影响对程序的理解。
在设计模块的时候，需要遵循每个模块功能单一、接口简单、结构精简的原则。确保每个模块的规模不要太大，接口尽量单一简化。这样可能会导致模块数量比较多，但能够确保模块的独立性，且不会影响系统的整体框架结构。
模块划分的意义： 功能完整独立，数据接口简单 程序易于实现，提高软件开发速度的同时能兼顾软件质量 程序实现逻辑更加清晰，可读性强，易于理解和维护 多人合作开发分工更明确，容易控制 系统运行可方便地选择不同的流程 易于测试和维护 有利于限制错误范围 抽象出可公用的模块，可维护性强，以避免同一处修改在多个地方出现 能充分利用可以重用的代码 基于模块化设计优秀的系统，方便的组装开发新的相似系统，甚至一个全新系统 模块划分准则 高内聚低耦合 规模适中 大模块分解不充分；小模块使用开销大，接口复杂。 功能单一明确 最好做到模块与目标的一一对应。方便单个模块的调试。 接口简单一致 设计应该使得信息传递简单并且与模块的功能一致。 尽量保证单入口单出口 避免内容耦合，易于理解和维护。 功能可预测
相同的输入应该有相同的输出，否则难以理解、测试和维护。 联系尽可能少 对于必须的联系都应该有明确的说明， 模块化的实现 抽象： 抽出事物的本质特性而暂时不考虑它们的细节
信息隐蔽： 一个模块内包含的信息（过程和数据）对于不需要这些信息的模块来说，是隐蔽不可访问的。
按照功能划分 在模块设计过程中大多基于功能来划分。这样做可以让相似的功能需求得到明确划分，同时有利于功能分解，任务分配等。
按照任务需求划分 按照任务需求进行模块划分是一种基于面向过程的划分方法，这样做能够清晰的了解系统的开发流程。对于任务的分工、管理，系统功能接口的制定都有良好体现。
按任务需求进行模块划分，可以先将任务需求根据系统框架分出系统等级。通过任务需求的等级划分对模块划分起到引导作用，同时，依照系统结构层次再来进行模块划分。
按任务需求进行模块划分的主要步骤如下：
分析系统需求，得出需求列表 对需求进行归类，并划分出优先级 根据需求对系统进行模块分析，抽取出核心模块 将核心模块进行细化扩展，逐层得到各个子模块，完成模块划分 很多情况下，在划分任务需求时，有些需求和多个模块均有联系，此时，通过需求来确定模块的划分就不能够降低模块间的耦合。而且有些模块划分出来后，里面涉及的数据类型多种多样，显然这个时候根据系统所抽象出来的数据模型来进行模块划分更加有利。</description>
    </item>
    
  </channel>
</rss>
