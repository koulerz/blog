<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>process on Kouler</title>
    <link>https://kouler.com/tags/process/</link>
    <description>Recent content in process on Kouler</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 28 Aug 2021 17:38:52 +0800</lastBuildDate><atom:link href="https://kouler.com/tags/process/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Docker 容器中的僵尸进程</title>
      <link>https://kouler.com/posts/docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Sat, 28 Aug 2021 17:38:52 +0800</pubDate>
      
      <guid>https://kouler.com/posts/docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</guid>
      <description>之前并非通过 docker stop 来停止程序和容器，而是通过容器中的 shell 脚本，在不停止容器的情况下，通过运行 shell 脚本来杀死程序。
这种方式导致每次停止程序后，被停止的进程都会变成一个僵尸进程。即被标记为 defunct 的进程。僵尸进程只能通过重启容器的方式消除。
尝试在容器内直接运行二进制程序，使其保持在前台运行，并通过 Ctrl + C 退出，不会产生僵尸进程。
docker 容器中僵尸进程产生的原因 Linux 中子进程通常由其父进程 fork 创建，并在子进程退出时回收子进程的资源。
当父进程先于子进程退出时，子进程会变成孤儿进程，而其父进程会变更为 init 进程。
当子进程已终止，但父进程尚未回收子进程资源时，子进程的残留资源（PCB）存放于内核中，变成僵尸进程。
Linux 中，若子进程缺失父进程，其残留资源会由 init 进程回收。但在 Docker 中，容器并非一个完整的操作系统，不会初始化 init 进程，容器中的第一个进程只是一个普通进程，所以并不会回收僵尸进程。
当使用 shell 脚本在后台执行目标程序时，shell 脚本会在启动目标程序后立刻退出而不会等待目标程序结束。shell 脚本尚未退出时，目标程序的父进程为当前脚本程序，而当 shell 脚本退出后，目标程序的父进程为当前终端进程。
终端进程并非 init 进程，不会回收孤儿进程的残留资源，所以子进程最终会变为僵尸进程。
问题修复 之前将 docker 容器当作虚拟机来使用，导致产生了很多问题并且没有真正减轻运维负担。
正确的做法是将 docker 容器作为单一服务，使用真正的容器化部署方式。</description>
    </item>
    
  </channel>
</rss>
