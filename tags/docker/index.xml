<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>docker on Kouler</title>
    <link>https://kouler.com/tags/docker/</link>
    <description>Recent content in docker on Kouler</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 28 Aug 2021 17:38:52 +0800</lastBuildDate><atom:link href="https://kouler.com/tags/docker/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Docker 容器中的僵尸进程</title>
      <link>https://kouler.com/posts/docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Sat, 28 Aug 2021 17:38:52 +0800</pubDate>
      
      <guid>https://kouler.com/posts/docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</guid>
      <description>之前并非通过 docker stop 来停止程序和容器，而是通过容器中的 shell 脚本，在不停止容器的情况下，通过运行 shell 脚本来杀死程序。
这种方式导致每次停止程序后，被停止的进程都会变成一个僵尸进程。即被标记为 defunct 的进程。僵尸进程只能通过重启容器的方式消除。
尝试在容器内直接运行二进制程序，使其保持在前台运行，并通过 Ctrl + C 退出，不会产生僵尸进程。
docker 容器中僵尸进程产生的原因 Linux 中子进程通常由其父进程 fork 创建，并在子进程退出时回收子进程的资源。
当父进程先于子进程退出时，子进程会变成孤儿进程，而其父进程会变更为 init 进程。
当子进程已终止，但父进程尚未回收子进程资源时，子进程的残留资源（PCB）存放于内核中，变成僵尸进程。
Linux 中，若子进程缺失父进程，其残留资源会由 init 进程回收。但在 Docker 中，容器并非一个完整的操作系统，不会初始化 init 进程，容器中的第一个进程只是一个普通进程，所以并不会回收僵尸进程。
当使用 shell 脚本在后台执行目标程序时，shell 脚本会在启动目标程序后立刻退出而不会等待目标程序结束。shell 脚本尚未退出时，目标程序的父进程为当前脚本程序，而当 shell 脚本退出后，目标程序的父进程为当前终端进程。
终端进程并非 init 进程，不会回收孤儿进程的残留资源，所以子进程最终会变为僵尸进程。
问题修复 之前将 docker 容器当作虚拟机来使用，导致产生了很多问题并且没有真正减轻运维负担。
正确的做法是将 docker 容器作为单一服务，使用真正的容器化部署方式。</description>
    </item>
    
    <item>
      <title>捕获 docker stop 信号</title>
      <link>https://kouler.com/posts/%E6%8D%95%E8%8E%B7docker-stop%E4%BF%A1%E5%8F%B7/</link>
      <pubDate>Sat, 28 Aug 2021 16:15:01 +0800</pubDate>
      
      <guid>https://kouler.com/posts/%E6%8D%95%E8%8E%B7docker-stop%E4%BF%A1%E5%8F%B7/</guid>
      <description>为了优化代码部署效率，将传统的手动部署方式改成了容器化部署方式
过去的程序停止逻辑  程序持续监听 SIGINT 信号 使用 Ctrl + C 快捷键向程序发送 SIGINT 信号 程序收到 SIGINT 信号后执行退出前的收尾工作 收尾工作执行完成后，程序自动退出  容器化后产生的问题 使用容器化部署方式后，期望通过 docker stop 命令来执行程序退出逻辑并关闭程序和容器，结果发现程序和容器被强制关闭，而程序退出前的收尾工作并未执行。
问题产生的原因 上网搜索后得知 docker stop 命令发送的并非 SIGINT 信号，而是 SIGTERM 信号。
而程序代码中并未捕获 SIGTERM 信号，所以收到 SIGTERM 信号后，程序跳过了收尾工作，直接退出了。
修复代码后的程序停止逻辑  程序持续监听 SIGINT 和 SIGTERM 信号 使用 docker stop 命令向程序发送 SIGTERM 信号 收到 SIGTERM 信号后执行退出前的收尾工作 收尾工作执行完成后，程序自动退出  修复代码后，使用 docker stop 命令能够按照预期正确退出程序。</description>
    </item>
    
    <item>
      <title>Docker 常用命令</title>
      <link>https://kouler.com/posts/docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 27 Jul 2020 00:22:31 +0800</pubDate>
      
      <guid>https://kouler.com/posts/docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>查看 Docker 信息   常看 docker 版本：
1$ docker version   查看 docker 系统信息：
1$ docker info   镜像操作  根据 Dockerfile 创建 Docker 镜像 1# 1. 首先创建一个新的目录 docker 2# 2. 在目录下新建 Dockerfile 文件 3# 3. 完善 Dockerfile 文件内容 4# 4. 在新创建的目录下使用 docker build 命令构建新的镜像 5#  6# 示例：[docker build -t go1.16.0:alpine .] 7 8$ docker build -t &amp;lt;新的镜像名&amp;gt;:&amp;lt;新镜像的tag&amp;gt; &amp;lt;Dockerfile文件所在路径&amp;gt;  从 DockerHub 检索镜像 1$ docker search &amp;lt;image_name&amp;gt;  拉取镜像 1$ docker pull &amp;lt;image_name&amp;gt;  删除镜像 1$ docker rmi &amp;lt;image_name&amp;gt;  列出镜像 1$ docker images  显示镜像历史 1$ docker history &amp;lt;image_name&amp;gt;  上传镜像到 Docker Hub 1# 为镜像添加附带作者信息的标签 2$ docker tag &amp;lt;image_name&amp;gt;:&amp;lt;label&amp;gt; &amp;lt;author_name&amp;gt;/&amp;lt;image_name&amp;gt;:&amp;lt;label&amp;gt; 3 4# 上传附带作者信息标签的镜像到 Docker Hub 5$ docker push &amp;lt;author_name&amp;gt;/&amp;lt;image_name&amp;gt;:&amp;lt;label&amp;gt;  清理镜像 1$ docker image prune   容器启动   启动容器并启动 bash：</description>
    </item>
    
  </channel>
</rss>
