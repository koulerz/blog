<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>database on Kouler</title>
    <link>https://kouler.com/tags/database/</link>
    <description>Recent content in database on Kouler</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 09 Jul 2021 02:52:43 +0800</lastBuildDate>
    
	<atom:link href="https://kouler.com/tags/database/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>PostgreSQL 中的字符串类型</title>
      <link>https://kouler.com/posts/use-postgres-character-type/</link>
      <pubDate>Fri, 09 Jul 2021 02:52:43 +0800</pubDate>
      
      <guid>https://kouler.com/posts/use-postgres-character-type/</guid>
      <description>    char varchar text     是否固定长度 是 否 否   空白字符补全 是 否 否   最大长度限制 指定的长度 指定的长度 无限制   默认长度 char(1) 无限制 无限制   超出范围 返回错误(若超出部分是空字符串则截取) 返回错误 无限制     char, varchar, text 类型之间几乎没有性能差异。char 类型因为填充空白字符效率可能更低 char 类型会在长度不足时以空白字符填补，所以当字符串末尾的空白字符有意义时，可能会产生混淆 任何情况下，PostgreSQL 能被存储的最长的字符串是 1GB，所以在类型中所谓的无限制，最长也不能超过 1GB text 等同于不限制长度的 carchar, 区别在于 varchar(n) 可以限制长度，数据超出长度时将会返回错误 相对于 text 类型，varchar(n) 明显的好处在于限制长度。但考虑到未来可能更改限制的长度，使用 text 类型并在代码逻辑中限制长度可能是更好的选择  参考  PostgreSQL 字符类型 char-varchar-text-性能测试  </description>
    </item>
    
    <item>
      <title>PostgreSQL 常用操作</title>
      <link>https://kouler.com/posts/postgresql%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sun, 03 Apr 2016 12:21:24 +0800</pubDate>
      
      <guid>https://kouler.com/posts/postgresql%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</guid>
      <description>增删改查 SQL 语句 1-- 插入数据 2INSERT INTO user_tbl(name, signup_date) VALUES(&amp;#39;张三&amp;#39;, &amp;#39;2013-12-22&amp;#39;); 3 4-- 查询记录 5SELECT * FROM user_tbl; 6 7-- 更新数据 8UPDATE user_tbl set name = &amp;#39;李四&amp;#39; WHERE name = &amp;#39;张三&amp;#39;; 9 10-- 删除记录 11DELETE FROM user_tbl WHERE name = &amp;#39;李四&amp;#39; ; 批量更新 SQL 语句 1-- 批量更新一个字段 2UPDATE mytable 3SET myfield = CASE id 4 WHEN 1 THEN &amp;#39;value&amp;#39; 5 WHEN 2 THEN &amp;#39;value&amp;#39; 6 WHEN 3 THEN &amp;#39;value&amp;#39; 7END 8WHERE id IN (1,2,3) 9 10-- 批量更新多个字段 11UPDATE categories 12SET display_order = CASE id 13 WHEN 1 THEN 3 14 WHEN 2 THEN 4 15 WHEN 3 THEN 5 16END, 17title = CASE id 18 WHEN 1 THEN &amp;#39;New Title 1&amp;#39; 19 WHEN 2 THEN &amp;#39;New Title 2&amp;#39; 20 WHEN 3 THEN &amp;#39;New Title 3&amp;#39; 21END 22WHERE id IN (1,2,3) 序列操作 SQL 语句 1-- 查看当前序列的值 2SELECT currval(&amp;#39;user_id_seq&amp;#39;); 3 4-- 设置序列的初始值为 100 5select setval(&amp;#39;user_id_seq&amp;#39;,100); 6 7-- 递增序列的值并返回 8select nextval(&amp;#39;user_id_seq&amp;#39;); 查询 SQL 语句 1-- 转换时间戳为格式化时间函数 TO_TIMESTAMP() 2SELECT TO_TIMESTAMP(created_at) FROM user; 3 4-- 转换时间戳为格式化时间函数 TO_TIMESTAMP() ，显示为中国时区 5-- 使用 &amp;#39;CST&amp;#39; 时区不一定显示为中国本地时间，建议使用 &amp;#39;Asia/Shanghai&amp;#39; 时区 6SELECT TO_TIMESTAMP(created_at) AT TIME ZONE &amp;#39;CST&amp;#39; FROM user; 7SELECT TO_TIMESTAMP(created_at) AT TIME ZONE &amp;#39;Asia/Shanghai&amp;#39; FROM user; 8 9-- 返回字段中的条件判断 10SELECT name, CASE sex WHEN 1 THEN &amp;#39;男&amp;#39; WHEN 2 THEN &amp;#39;女&amp;#39; ELSE &amp;#39;保密&amp;#39; END AS sex, age FROM user; 11 12-- 拼接字符串 13SELECT CONCAT(&amp;#39;姓名:&amp;#39;, name) AS name, age FROM user; 14 15-- 数值计算 16SELECT id, amount/100 FROM order; 17 18-- 保留 2 位小数精度 19SELECT id, round(100/3, 2) FROM order; 20 21-- 解析数组格式数据，获取数据时先将数组转为 JSON，再用编程语言函数将 JSON 转为可识别格式，例如 PHP 中的 json_decode() 22SELECT array_to_json(ids) FROM user; Schema 操作 SQL 语句 1-- 创建新表 2CREATE TABLE user_tbl(name VARCHAR(20), signup_date DATE); 3 4-- 添加字段 5ALTER TABLE user_tbl ADD email VARCHAR(40); 6ALTER TABLE user_tbl ADD COLUMN images jsonb DEFAULT &amp;#39;{}&amp;#39;; 7 8-- 更改字段类型 9ALTER TABLE user_tbl ALTER COLUMN signup_date SET NOT NULL; 10 11-- 更改字段类型长度 12ALTER TABLE user_tbl ALTER COLUMN password TYPE varchar(32); 13 14-- 为字段添加索引 15CREATE INDEX index_name ON user_tbl (name); 16 17-- 设置字段默认值（注意字符串使用单引号） 18ALTER TABLE user_tbl ALTER COLUMN email SET DEFAULT &amp;#39;example@example.</description>
    </item>
    
    <item>
      <title>PostgreSQL 中 JSON 和 JSONB 的区别</title>
      <link>https://kouler.com/posts/postgresql%E4%B8%ADjson%E5%92%8Cjsonb%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 02 Apr 2016 15:47:06 +0800</pubDate>
      
      <guid>https://kouler.com/posts/postgresql%E4%B8%ADjson%E5%92%8Cjsonb%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>Postgres 中的 Json 和 Jsonb 数据类型都是用于储存 JSON ( JavaScript Object Notation ) 格式数据。虽然 Text 数据类型也可以用来储存 JSON 数据， 但 JSON 数据类型的优势在于它会根据 JSON 规则来强制要求每个被储存的值都是合法的 JSON 数据。
一般情况下， 除非有特别的要求（比如针对对象键排列顺序的遗留假设，legacy assumption）， 否则的话， 大多数应用程序都应该优先使用 jsonb 类型来储存 JSON 数据。
Json 数据类型 json 数据类型储存输入文本的精确拷贝，处理函数在每次执行的时候，都必须对这些文本重新进行分析。
json 数据类型会保留文本中与 Json 语义完全无关的空白字符，各个键在 Json 对象内的排列顺序以及具有相同键的值。
Jsonb 数据类型 Jsonb 数据类型以无压缩（decomposed）二进制格式来储存数据，因为格式转换带来的花销，这种类型在处理输入的时候速度会稍微慢一些，但是因为这种类型的数据并不需要重新进行分析，所以这种数据的处理速度会明显地快很多。
jsonb 支持索引特性，这是一个明显的优点。
jsonb 不会保留任何无关的空白，不会保留对象键的排列顺序，也不会保留任何重复的对象键。如果输入里面指定了重复的键，那么只有最后一个值会被保留。
jsonb 类型可以检测一个 jsonb 值是否包含了另一个 jsonb 值，而 json 类型并不具备这样的特性。
jsonb 会拒绝那些超出 PostgreSQL 数字类型范围的数字，而 json 则不会这样做。
参考 &amp;amp; 扩展  JSON 类型 JSON Functions and Operators PostgreSQL 9.</description>
    </item>
    
  </channel>
</rss>